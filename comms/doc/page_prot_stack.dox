/// @page page_prot_stack_tutorial Protocol Stack Tutorial
/// @tableofcontents
/// @section page_prot_stack_tutorial_intro Introduction
/// In addition to definition of the messages and their contents, every 
/// communication protocol must ensure that the message is successfully delivered
/// over the I/O link to the other side. The serialised message payload must
/// be wrapped in some kind of transport information prior to being sent and 
/// unwrapped on the other side when received.
///
/// For example, let's define a custom protocol that wraps the message payload
/// in the following way:
/// @code
/// SYNC | SIZE | ID | PAYLOAD | CHECKSUM 
/// @endcode    
/// where:
/// @li SYNC - 2 bytes of synchronisation value to indicate beginning of the message, 
///     must be "0xab 0xcd"
/// @li SIZE - 2 bytes, length of remaining data including checksum and not 
///     including SIZE field itself.
/// @li ID - 1 byte, numeric ID of the message.
/// @li PAYLOAD - any number of bytes, serialised message data
/// @li CHECKSUM - 2 bytes, CRC-CCITT value of all bytes starting (and
///     including) from SIZE field and ending after PAYLOAD field.
/// 
/// The processing of the raw bytes received over I/O link involves identifying
/// the fields listed above and stripping them off <b>one by one</b> until the
/// @b PAYLOAD is reached, where it can be read by the created proper message
/// object (based on read message ID). If one of the elements is not as it is 
/// expected to be, the processing should stop.
///
/// The sequential processing the the transport information values, and stripping
/// them one by one before proceeding to the next one, may remind of 
/// <a href="https://en.wikipedia.org/wiki/OSI_model">OSI Conceptual Model</a>, where
/// a layer serves the layer above it and is served by the layer below it. 
///
/// The @b COMMS library defines every such @b layer, that is handling a single
/// value, as separate class. Every such layer class will use @b field abstraction
/// (see @ref page_field_tutorial) to wrap the value it handles.
/// The layer classes are stacked together by wrapping
/// one another. When combined together they are called <b>Protocol Stack</b>.
///
/// The wrapping for the example above will look like this:
/// @diafile protocol_stack.dia
///
/// When presented as actual stack, it may look like this:
/// @diafile protocol_stack_layers.dia
///
/// Please note that @b CHECKSUM layer lays between @b SYNC and @b SIZE. This is
/// a bit counter intuitive, because @b SIZE follows @b SYNC in the protocol
/// description, while @b CHECKSUM appears last. The reason for such location
/// of @b CHECKSUM layer is that it calculates and verifies checksum on the
/// @b SIZE, @b ID, and @b PAYLOAD areas, i.e. it must wrap the all three.
///
/// The COMMS library provides multiple classes to define various layers when
/// assembling the full <b>protocol stack</b> of layers. All these classes reside in
/// comms::protocol namespace.
/// The following sections will cover all the layer classes required to
/// assemble the protocol stack described above.
///
/// @section page_prot_stack_tutorial_payload PAYLOAD Layer
/// The top layer, that is responsible to read/write the payload of the message
/// is called @b PAYLOAD. It is implemented by comms::protocol::MsgDataLayer
/// class in the COMMS library. 
/// @code
/// using MyMsgData = comms::protocol::MsgDataLayer<>;
/// @endcode
/// @b NOTE, that @ref comms::protocol::MsgDataLayer receives a template parameter.
/// In the normal operation, when transport frame fields are not stored anywhere,
/// it is never used. However, there is way to perform @b read operation while
/// caching transport fields (by using @ref comms::protocol::MsgDataLayer::readFieldsCached())
/// The payload field is defined to be @ref comms::field::ArrayList of raw data
/// (see @ref comms::protocol::MsgDataLayer::Field). It would be wise to provide
/// a way to supply extra options to choose storage type for this field,
/// when defining protocol stack. As the result the definition becomes:
/// @code
/// template <typename TPayloadOptions = comms::option::EmptyOption>
/// using MyMsgData = comms::protocol::MsgDataLayer<TPayloadOptions>;
/// @endcode
///
/// @section page_prot_stack_tutorial_id ID Layer
/// The @b ID layer is responsible to process the ID of the message
/// and based on this ID, create proper message object. The COMMS library implements
/// this functionality in comms::protocol::MsgIdLayer class. It receives 
/// <b>at least</b> four template parameters. The first one is a type of the
/// field that can be used to read/write the ID information. The @ref
/// page_define_prot_interface section described @b my_protocol::MsgId enum
/// type used to define message IDs, it can be reused to define a field responsible
/// to read / write message ID value 
/// @code
/// namespace my_protocol
/// {
///
/// enum MsgId : std::uint8_t {...} // enum described earlier
///
/// using MyFieldBase = comms::Field<comms::option::BigEndian>; // Use big endian for all fields serialisation
///
/// using MsgIdField = 
///     comms::field::EnumValue<
///         MyFieldBase, 
///         MsgId // enum type
///     >;
///
/// } // namespace my_protocol
/// @endcode
/// @b NOTE, that underlying enum type is defined to be @b std::uint8_t, which
/// will result in 1 byte serialisation length.
///
/// The second parameter is common interface class for all @b input messages
/// that need to be recognised during @b read operation. This type will be defined
/// by the application and is expected to be an alias (typedef) or extending 
/// class to @b my_protocol::Message (described in @ref page_define_prot_interface)
/// 
/// The third parameter
/// is all the types of all the custom messages, that need to be recognised in
/// @b read operation, bundled in std::tuple. 
/// @code
/// template <typename TMessage>
/// using AllInputMessages =
///     std::tuple<
///         Message1<TMessage>,
///         Message2<TMessage>,
///         Message3<TMessage>,
///         ...
///     >;
/// @endcode
/// @b NOTE, that the interface class (@b TMessage) passed as
/// the second parameter is expected to be the common base class for all the messages
/// passed as third one.
/// 
/// The fourth template parameter is the upper layer it needs to wrap:
/// @code
/// template <
///     typename TMessage, // common interface class defined by the application
///     typename TInputMessages = AllInputMessages<TMessage>, // Input messages that need to be recognised
///     typename TPayloadOptions = comms::option::EmptyOption // Extra options for payload storage
/// >
/// using MyMsgId = 
///     comms::protocol::MsgIdLayer<
///         MsgIdField, 
///         TMessage, 
///         TInputMessages, 
///         MyMsgData<TPayloadOptions>
///     >;
/// @endcode 
/// @b NOTE, that all the input messages are passed as a template parameter with
/// a default value (bundling all the available messages). It will give an opportunity
/// to the application to use only messages it needs.
///
/// Also @b note, input messages in the bundle (@b TInputMessages) are expected
/// to be defined in order of their numeric IDs. It is allowed to have separate
/// message classes to report the same numeric ID. However, the @b read operation will
/// try to read all the messages with the found ID one by one <b>in
/// order</b> of their definition until success is reported.
///
/// The comms::protocol::MsgIdLayer defines @b MsgPtr 
/// (see comms::protocol::MsgIdLayer::MsgPtr) internal type, which is
/// smart pointer (@b std::unique_ptr) to the input message interface
/// class (@b TMessage) provided as second template parameter.
///
/// During the normal @b read operation, the comms::protocol::MsgIdLayer will
/// dynamically allocate the proper message object.
///
/// The comms::protocol::MsgIdLayer can also be used in <b>bare metal</b> systems,
/// that do NOT use dynamic memory allocation. In order to prevent this layer 
/// from using dynamic memory allocation, the comms::option::InPlaceAllocation
/// option needs to be passed as fifth template parameter to the
/// comms::protocol::MsgIdLayer class. However, an ability to use this option
/// needs to be provided to the application itself only if needed. In order to
/// achive that additional template parameter needs to be used.
/// @code
/// template <
///     typename TMessage, // common interface class defined by the application
///     typename TInputMessages = AllInputMessages<TMessage>, // Input messages that need to be recognised
///     typename TAllocationOptions = comms::option::EmptyOption, // Extra options for MsgIdLayer
///     typename TPayloadOptions = comms::option::EmptyOption // Extra options for payload storage
/// >
/// using MyMsgId = 
///     comms::protocol::MsgIdLayer<
///         MsgIdField, 
///         TMessage, 
///         TInputMessages, 
///         MyMsgData<TPayloadOptions>,
///         TAllocationOptions
///     >;
/// @endcode 
/// In this case, the comms::protocol::MsgIdLayer will statically allocate 
/// internal buffer in its private data members, big enough to hold any message object
/// of any type listed in @b AllInputMessages bundle. It means that only one message
/// object can be allocated and used at a time, i.e. the previous object must
/// be deleted prior to new one being allocated. @n
/// Also, the comms::protocol::MsgIdLayer::MsgPtr will still be a variant of
/// @b std::unique_ptr, but with custom deleter (defined by COMMS library itself),
/// which will make sure the proper destruction of the message object and
/// release of the internal buffer for next allocation. In case new allocation
/// is attempted when internal buffer is NOT released, the new message will NOT be allocated
/// and read operation will fail with @ref comms::ErrorStatus::MsgAllocFailure
/// error.
///
/// By default, if the received data contains unknown message ID (the message
/// type is not in @b AllInputMessages bundle), the @b read operation returns
/// @ref comms::ErrorStatus::InvalidMsgId and no message object is allocated.
/// However, there are @b bridge / @b gateway / @b firewall type of applications
/// which are interested to decode only limited number of messages, but still
/// forward the received data (sometimes changing the transport wrapping) 
/// without actually decoding the contents. In this case the default behaviour 
/// cannot be used. The @b COMMS library provides @ref comms::GenericMessage 
/// message definition which has a single variable length data field 
/// (defined using @ref comms::field::ArrayList class). The @ref
/// comms::protocol::MsgIdLayer may also receive @ref comms::option::SupportGenericMessage
/// option specifying type of the GenericMessage. 
/// In this case, if the appropriate message type hasn't been found in 
/// @b AllInputMessages bundle, the appropriate @ref comms::GenericMessage object
/// will be created instead. However, just like with
/// @ref comms::option::InPlaceAllocation, this option should be used by the application
/// if needed.
///
/// Note, that comms::option::SupportGenericMessage and comms::option::InPlaceAllocation
/// options can be used together. In this case the @ref comms::GenericMessage
/// message object will be allocated in the same allocation area. The client
/// application will be able to combine these option together in single tuple
/// and use pass as @b TAllocationOptions parameter.
/// @code
/// using MyAllocOptions = 
///     std::tuple<
///         comms::option::SupportGenericMessage<comms::GenericMessage<MyInterfaceMessage> >,
///         comms::option::InPlaceAllocation
///     >;
/// @endcode
/// When constructed, the comms::protocol::MsgIdLayer creates an array of
/// statically allocated factory methods, which are responsible to allocate
/// right message objects. This array is used as a map of message ID to the
/// factory method. The COMMS library contains inner logic that analyses a tuple of all @b input message
/// types provided to @ref comms::protocol::MsgIdLayer. If the IDs of the messages
/// are sequential ones starting from a low number such as 0 or 1, and the highest
/// ID value do not significantly exceed the total number of message types in the tuple,
/// then the one-to-one mapping is generated, i.e. to access the right factory 
/// method is just accessing the right cell in the mapping array (O(1) time complexity).
/// In all other cases the factory methods are compacted together and binary search
/// is executed to get appropriate factory method having the numeric message ID 
/// value (O(log(n))).
///
/// @b NOTE, that comms::protocol::MsgIdLayer doesn't use any dynamic memory
/// allocation to store internal factory methods, that create proper message
/// object given the ID of the message, which makes it possible and safe to
/// use in bare-metal environment without any HEAP.
///
/// It may happen that @b comms::protocol::MsgIdLayer class as-is is not really
/// suitable for implementing message identification and creation of message
/// object when implementing custom protocol. 
/// It is possible to implement a new custom layer (see @ref
/// page_prot_stack_tutorial_new_layers section below) with the required
/// functionality. However, it is recommended
/// to use @ref comms::MsgFactory object internally. It will help in creation the proper
/// message object once the ID value is known.
///
/// @section page_prot_stack_tutorial_size SIZE Layer
/// The @b SIZE layer is responsible to process information on the remaining
/// message length, and forward the @b read/write operations to the upper layer
/// in case it is safe to do so. The COMMS library provides 
/// @ref comms::protocol::MsgSizeLayer class for that purpose.
/// @code
/// namespace my_protocol
/// {
///
/// using RemSizeField =
///     comms::field::IntValue<
///         MyFieldBase, 
///         std::uint16_t, 
///         comms::option::NumValueSerOffset<sizeof(std::uint16_t)> 
///     >;
///
/// template <
///     typename TMessage, // common interface class defined by the application
///     typename TInputMessages = AllInputMessages<TMessage>, // Input messages that need to be recognised
///     typename TAllocationOptions = comms::option::EmptyOption, // Extra options for MsgIdLayer
///     typename TPayloadOptions = comms::option::EmptyOption // Extra options for payload storage
/// >
/// using MyMsgSize = 
///     comms::protocol::MsgSizeLayer<
///         RemSizeField, 
///         MyMsgId<TMessage, TInputMessages, TAllocationOptions, TPayloadOptions> 
///     >;
/// 
/// } // namespace my_protocol
/// @endcode
/// The @ref comms::protocol::MsgSizeLayer receives two template parameters. The first
/// one is the definition of the @b field (see @ref page_field_tutorial for details)
/// that is responsible to read/write the remaining length information. The
/// second template parameter is an upper layer that is being wrapped. @n
/// Please note the usage of @b comms::option::NumValueSerOffset option when
/// defining the @b field type. If it is NOT used, the serialised length value
/// will cover only @b ID and @b PAYLOAD (layers it wraps). However, according to the protocol
/// specification, the @b SIZE value must also include @b CHECKSUM. Usage of
/// comms::option::NumValueSerOffset <sizeof(std::uint16_t)> will add 2
/// (@b sizeof(std::uint16_t)) when serialising the length of wrapped fields.
/// See also @ref sec_field_tutorial_int_value_ser_offset for more details.
///
/// @section page_prot_stack_tutorial_checksum CHECKSUM Layer
/// The @b CHECKSUM layer is responsible to calculate and verify the checksum
/// on the data read and/or written by the upper layers it wraps.
/// The COMMS library provides comms::protocol::ChecksumLayer and
/// comms::protocol::ChecksumPrefixLayer for this purpose. They are very similar.
/// The only difference is that comms::protocol::ChecksumLayer appends the 
/// checksum value, while comms::protocol::ChecksumPrefixLayer prepends it.
/// @code
/// namespace my_protocol
/// {
///
/// using ChecksumField = comms::field::IntValue<MyFieldBase, std::uint16_t>;
///
/// template <
///     typename TMessage, // common interface class defined by the application
///     typename TInputMessages = AllInputMessages<TMessage>, // Input messages that need to be recognised
///     typename TAllocationOptions = comms::option::EmptyOption, // Extra options for MsgIdLayer
///     typename TPayloadOptions = comms::option::EmptyOption // Extra options for payload storage
/// >
/// using MyChecksum =
///     comms::protocol::ChecksumLayer<
///         ChecksumField,
///         comms::protocol::checksum::Crc_CCITT
///         MyMsgSize<TMessage, TInputMessages, TAllocationOptions, TPayloadOptions>
///     >;
/// 
/// } // my_protocol
/// @endcode
/// The both layer classes receives three template parameters. The
/// first one is a @b field that is responsible to read/write the checksum value.
///
/// The second template parameter is a checksum calculator class which is used
/// to calculate a checksum value. Please refer to the documentation of
/// @ref comms::protocol::ChecksumLayer or @ref comms::protocol::ChecksumPrefixLayer class 
/// for the details on the interface this
/// checksum calculator class must provide. The example above uses 
/// @ref comms::protocol::checksum::Crc_CCITT, which calculates the the standard
/// CRC-CCITT value. All the checksum calculators the COMMS library provides reside
/// in comms::protocol::checksum namespace. 
///
/// The third template parameter is an upper layer that is being wrapped.
///
/// By default both @ref comms::protocol::ChecksumLayer and 
/// @ref comms::protocol::ChecksumPrefixLayer allow inner (upper) layers to 
/// complete their read operation before calculating and verifying checksum on
/// read data. However, there may be protocols that may allow checksum verification
/// before attempting to read message contents. In this case 
/// @ref comms::option::ChecksumLayerVerifyBeforeRead option may be used as
/// fourth template parameter.
/// @code
/// namespace my_protocol
/// {
/// template <
///     typename TMessage, // common interface class defined by the application
///     typename TInputMessages = AllInputMessages<TMessage>, // Input messages that need to be recognised
///     typename TAllocationOptions = comms::option::EmptyOption, // Extra options for MsgIdLayer
///     typename TPayloadOptions = comms::option::EmptyOption // Extra options for payload storage
/// >
/// using MyChecksum =
///     comms::protocol::ChecksumLayer<
///         ChecksumField,
///         comms::protocol::checksum::Crc_CCITT
///         MyMsgSize<TMessage, TInputMessages, TAllocationOptions, TPayloadOptions>,
///         comms::option::ChecksumLayerVerifyBeforeRead
///     >;
/// 
/// @endcode
///
/// @section page_prot_stack_tutorial_sync SYNC Layer
/// The @b SYNC layer is responsible to recognise the synchronisation byte(s)
/// in the input stream as well as write appropriate value when the write
/// operation takes place. The COMMS library provides @ref comms::protocol::SyncPrefixLayer
/// class that helps with this task.
/// @code
/// namespace my_protocol
/// {
///
/// using SyncField =
///     comms::field::IntValue<
///         MyFieldBase, 
///         std::uint16_t, 
///         comms::option::DefaultNumValue<0xabcd>,
///         comms::option::ValidNumValue<0xabcd>,
///         comms::option::FailOnInvalid // fail read operation if read value is invalid 
///     >;
///
/// template <
///     typename TMessage, // common interface class defined by the application
///     typename TInputMessages = AllInputMessages<TMessage>, // Input messages that need to be recognised
///     typename TAllocationOptions = comms::option::EmptyOption, // Extra options for MsgIdLayer
///     typename TPayloadOptions = comms::option::EmptyOption // Extra options for payload storage
/// >
/// using MySyncPrefix = 
///     comms::protocol::SyncPrefixLayer<
///         SyncField, 
///         MyChecksum<TMessage, TInputMessages, TAllocationOptions, TPayloadOptions> 
///     >;
/// 
/// } // namespace my_protocol
/// @endcode
/// The comms::protocol::SyncPrefixLayer class receives two template parameters.
/// The first one is the type of the @b field, that is responsible to read/write
/// the synchronisation byte(s). Please note the usage of comms::option::DefaultNumValue
/// option when defining the @b field type. It insures that the default constructed
/// field will have the required value. @n
/// The second template parameter is the upper layer being wrapped.
///
/// @section page_prot_stack_tutorial_transport_value Extra Transport Values
/// Some protocol may use extra values as part of the transport information. Such
/// values may have an influence on how the message payload is read and/or on
/// how the message object is handled. As an example let's define the following
/// transport wrapping:
/// @code
/// SIZE | ID | VERSION | PAYLOAD
/// @endcode
/// The @b VERSION value is expected to influence the "read" operation. The message
/// object may have some extra fields, which were introduced in later version of
/// the protocol, and it needs to take into account the provided @b VERSION info.
///
/// The COMMS library provides @ref comms::protocol::TransportValueLayer to handle
/// such fields. @b HOWEVER it requires extra support from common message interface class.
/// The latter must use @ref comms::option::ExtraTransportFields option in order
/// to define expected interface (please refer to @ref page_define_prot_interface_extra_transport
/// for details).
///
/// The @ref comms::protocol::TransportValueLayer class receives three 
/// template parameters. The first one is the field used to read / write the
/// value. The second parameter is index of the relevant extra transport field
/// in the @ref comms::Message::TransportFields tuple. And the third parameter
/// is the next layer.
///
/// The whole protocol stack definition may look like this:
/// @code
/// // Base class of all the fields
/// using MyFieldBase = comms::Field<comms::option::BigEndian>;
///
/// // Field describing protocol version.
/// using MyVersionField = comms::field::IntValue<MyFieldBase, std::uint16_t>;
///
/// // Payload control layer
/// using MyMsgData = comms::protocol::MsgDataLayer<>;
///
/// // Version control layer
/// using MyVersion = 
///     comms::protocol::TransportValueLayer<
///         MyVersionField, 
///         MyMessage::TransportFieldIdx_version, 
///         MyMsgData
///     >;
///
/// // Id handling layer
/// using MyMsgId = comms::protocol::MsgIdLayer<MsgIdField, MyMessage, AllInputMessages, MyVersion>;
///
/// // Size handling layer
/// using MyMsgSize = comms::protocol::MsgSizeLayer<RemSizeField, MyMsgId>;
///
/// // Full stack is the outmost layer
/// using ProtocolStack = MyMsgSize; 
/// @endcode
/// @b NOTE, that in the example above @b VERSION layer follows @b ID. In this case
/// the message object is already created by the @b ID layer when @b VERSION
/// one performs its read operation. The latter may update the version information
/// inside the created message object. However, there may be cases when 
/// extra transport value precedes ID layer:
/// @code
/// SIZE | VERSION | ID | PAYLOAD
/// @endcode
/// The COMMS library is also capable of handling such case. It contains internal
/// "magic", which forces some layers to complete their read operation and
/// update created message object (if necessary) before
/// the read operation is forwarded to the final (PAYLOAD) layer.
///
/// Unfortunatelly there are layers (@ref comms::protocol::ChecksumLayer,
/// @ref comms::protocol::ChecksumPrefixLayer, and @ref comms::protocol::MsgSizeLayer),
/// that cannot complete their read operation, without read of the PAYLOAD data
/// being complete as well. As the result these layers do not support being wrapped by 
/// @ref comms::protocol::TransportValueLayer and will fail compilation with
/// static assert if such wrapping is attempted.
/// 
/// @section page_prot_stack_tutorial_summary Layers Summary
/// The earlier examples show that layer classes wrap one another, which creates
/// the following picture:
/// @diafile protocol_stack.dia
///
/// The outermost (or bottom) layer defines a full <b>protocol stack</b>. It 
/// should be typedef-ed to avoid any confusion:
/// @code
/// using ProtocolStack = MySyncPrefix;
/// @endcode
///
/// In order to get an information on the available API functions as well as
/// public types of the protocol stack please refer to the documentation of
/// the outermost layer class.
///
/// The comms::protocol::MsgIdLayer defines proper type of smart pointer to the message
/// interface class (@b MsgPtr). Every other layer re-defines the same type as
/// its internal @b MsgPtr type. Instantiating such pointer is as simple as:
/// @code
/// ProtocolStack::MstPtr msgPtr;
/// @endcode
///
/// @section page_prot_stack_tutorial_read Reading Transport Info and Message Payload
/// Below is an example of how to implement data processing loop, which parses
/// the raw bytes in the provided input buffer, creates appropriate message 
/// message object and dispatches it to the right handler.
/// @code
/// ProtStack protStack; // Protocol stack defined in previous section
/// MyHandler handler; // Handler object
///
/// // Receives input buffer and its size and returns number of consumed bytes
/// std::size_t processInput(const std::uint8_t* buf, std::size_t len)
/// {
///     std::size_t consumed = 0U;
///     // Processing loop
///     while (consumed < len) {
///         // Smart pointer to the message object.
///         ProtStack::MsgPtr msgPtr; 
///
///         // Type of the message interface class
///         using MsgType = ProtStack::MsgPtr::element_type; 
///     
///         // Get the iterator for reading
///         auto begIter = comms::readIteratorFor<MsgType>(buf + consumed);
///         auto iter = begIter;
///
///         // Do the read
///         auto es = protStack.read(msgPtr, iter, len - consumed);
///         if (es == comms::ErrorStatus::NotEnoughData) {
///             break; // Not enough data in the buffer, stop processing
///         } 
///     
///         if (es == comms::ErrorStatus::ProtocolError) {
///             // Something is not right with the data, remove one character and try again
///            ++consumed;
///             continue;
///         }
///
///         if (es == comms::ErrorStatus::Success) {
///             assert(msgPtr); // If read is successful, msgPtr is expected to hold a valid pointer
///             msgPtr->dispatch(handler); // Dispatch message for handling
///         }
///
///         // The iterator for reading has been advanced, update the difference
///         consumed += std::distance(begIter, iter);
///     }
///
///     // Report how many bytes have been consumed from the buffer
///     return consumed;
/// }
/// @endcode
/// Please pay attention to the following details:
/// @li The protocol stack type defines type of the smart pointer that 
///     holds message object that was allocation during @b read operation:
///     @code
///     ProtStack::MsgPtr msgPtr;
///     @endcode
/// @li The @b ProtStack::MsgPtr is a variant of 
///     <a href="http://en.cppreference.com/w/cpp/memory/unique_ptr">unique_ptr</a>.
///     As the result the type of the interface can be retrieved using internal
///     type @b element_type:
///     @code
///     using MsgType = ProtStack::MsgPtr::element_type;
///     @endcode
/// @li The innermost layer of protocol stack (comms::protocol::MsgDataLayer)
///     will invoke @b polymorphic read interface of the allocated message
///     (see comms::Message::read()). It means that the iterator used 
///     for reading needs to be convertible to comms::Message::ReadIterator. It
///     can be achieved by using comms::readIteratorFor() template function, 
///     which will initialise and return appropriate iterator type. Another 
///     possible way of allocating the iterator can be as following:
///     @code
///     MsgType::ReadIterator iter = buf + consumed;
///     @endcode
/// @li After the read operation is determined to be successful, the @b msgPtr
///     holds dynamically allocated message object. The dispatching of the
///     message for the handling is performed using polymorphic @b dispatch()
///     call (see @ref page_message_tutorial_interface_handle for details).
///
///
/// @section page_prot_stack_tutorial_write Writing Transport Info and Message Payload
/// The easiest way to implement write functionality is to use the ability of
/// the message object to perform polymorphic write (see 
/// @ref page_message_tutorial_interface_write)
/// @code
/// ProtStack protStack; // Protocol stack defined in one of previous sections
/// void sendMessage(const MyMessage& msg)
/// {
///     std::vector<std::uint8_t> dataToSend; // Data to be sent via I/O link
///
///     auto reqLen = protStack.length(msg); // Number of bytes required to serialise the message;
///     dataToSend.resize(reqLen);
///     auto writeIter = comms::writeIteratorFor<MyMessage>(&dataToSend[0]);
///     auto es = protStack.write(msg, writeIter, dataToSend.size());
///     if (es == comms::ErrorStatus::Success) {
///         ... // Send contents of dataToSend via I/O link
///     }
/// }
/// @endcode
/// Please pay attention to the following details:
/// @li The code above accesses the message via the interface class, which
///     requires it to provide polymorphic write (see 
///     @ref page_message_tutorial_interface_write) and polymorphic serialisation length
///     calculation (see @ref page_message_tutorial_interface_length).
/// @li The code above assumes usage of random-access iterator for writing
///     purposes, which will allow proper checksum calculation, as the result
///     the write operation is expected to succeed.
/// @li The innermost layer of protocol stack (comms::protocol::MsgDataLayer)
///     will invoke @b polymorphic write interface of the allocated message
///     (see comms::Message::write()). It means that the iterator used for
///     writing needs to be convertible to comms::Message::WriteIterator. It
///     can be achieved by using comms::writeIteratorFor() template function, 
///     which will initialise and return appropriate iterator type. Another 
///     possible way of allocating the iterator can be as following:
///     @code
///     MyMessage::WriteIterator iter = buf + consumed;
///     @endcode
///
/// As an extra example, let's rewrite the code above to use the 
/// @b std::back_insert_iterator. NOTE, that it will require redefinition of the interface
/// class.
/// @code
/// class MyMessage : public
///     comms::Message<
///         ...
///         comms::option::WriteIterator<std::back_insert_iterator<std::vector<uint8_t> > >, 
///     >
/// {
///     ...
/// };
/// @endcode
/// Here comes the actual write function:
/// @code
/// ProtStack protStack; // Protocol stack defined in one of previous sections
/// void sendMessage(const MyMessage& msg)
/// {
///     std::vector<std::uint8_t> dataToSend; // Data to be sent via I/O link
///
///     auto writeIter = std::back_inserter(dataToSend);
///     auto es = protStack.write(msg, writeIter, dataToSend.max_size());
///     if (es == comms::ErrorStatus::UpdateRequired) {
///         // The checksum could not be calculated right away, 
///         // create random-access iterator and update the written value
///         auto* updateIter = &dataToSend[0];
///         es = proptStack.update(updateIter, dataToSend.size());
///     }
///
///     if (es == comms::ErrorStatus::Success) {
///         ... // Send contents of dataToSend via I/O link
///     }
/// }
/// @endcode
/// In this case the comms::protocol::ChecksumLayer won't be able to inspect the
/// written code right away and calculate the checksum value. As the result,
/// @ref comms::ErrorStatus::UpdateRequired is expected to be returned. To fix the serialised
/// data, random access iterator to the written data needs to be created and 
/// @b update() member function of the protocol stack invoked.
///
/// The assembled <b>Protocol Stack</b> does not require usage of polymorphic
/// write for message serialisation all the time. If number of messages being 
/// sent is not very high, sometimes it makes sense to avoid adding an ability
/// to support polymorphic write in the common interface. In this case the
/// sending functionality can be implemented as below:
/// @code
/// template <typename TMsg>
/// void sendMessage(const TMsg& msg)
/// {
///     std::vector<std::uint8_t> dataToSend; // Data to be sent via I/O link
///
///     auto writeIter = std::back_inserter(dataToSend);
///     auto es = protStack.write(msg, writeIter, dataToSend.max_size());
///     ...
/// }
/// @endcode
/// Such implementation does not require any polymorphic behaviour from the
/// message object being sent. In fact, it may make sense to define two 
/// separate interface classes, one for input messages, and another for output 
/// ones.
/// @code
/// // Input messages will require polymorphic read and dispatch
/// using MyInputMessage = 
///     comms::Message<
///         comms::option::BigEndian,
///         comms::option::MsgIdType<MyMsgId>,
///         comms::option::ReadIterator<const std::uint8_t*>,
///         comms::option::Handler<MyHandler>
///     >;
///
/// // Output messages don't require any polymorphic behaviour
/// using MyOutputMessage = 
///     comms::Message<
///         comms::option::BigEndian,
///         comms::option::MsgIdType<MyMsgId>
///     >;
/// @endcode
///
/// @section page_prot_stack_tutorial_caching Access to Processed Stack Fields
/// All the examples above do not store the read/written protocol stack fields
/// anywhere. In most cases it is not needed. However, if need arises they can
/// be cached during the read/write operations and accessed later. Every
/// layer defines @b AllFields type which is std::tuple of all the fields used by all the 
/// layers starting from the defining one, up to the top of the stack. @n
/// Also, every layer defines @b readFieldsCached() and @b writeFieldsCached()
/// functions which are substitutes to normal read() and write(). The first
/// parameter to these functions is reference to the @b AllFields bundle
/// object.
/// @code
/// ProtocolStack::AllFields fields;
/// auto es = protocolStack.readFieldsCached<0>(fields, msgPtr, readIter, bufSize);
/// ...
/// // Access the fields from the described protocol
/// auto& syncValueField = std::get<0>(fields);
/// auto& checksumValueField = std::get<1>(fields);
/// auto& sizeValueField = std::get<2>(fields);
/// auto& msgIdField = std::get<3>(fields);
/// auto& payloadField = std::get<4>(fields);
/// ...
/// @endcode
///
/// @section page_prot_stack_tutorial_new_layers Implementing New Layers
/// Every protocol is unique, and there is a chance that COMMS library doesn't
/// provide all the necessary layer classes required to implement custom logic
/// of the protocol. The COMMS library allows implementation and usage of 
/// custom layers as long as it defines the required types and implements required
/// functions. It is strongly recommended to inherit from comms::protocol::ProtocolLayerBase
/// and implement missing functionality
/// @code
/// // Must receive the next layer type as template parameter
/// template <typename TField, typename TNextLayer>
/// class MyLayer : public 
///     comms::protocol::ProtocolLayerBase<
///         TField, 
///         TNextLayer,
///         MyLayer<TField, TNextLayer>
///     >
/// {
/// public:
///     // Implement read
///     template <typename TMsgPtr, typename TIter, typename TNextLayerReader>
///     comms::ErrorStatus doRead(
///         Field& field,
///         TMsgPtr& msgPtr,
///         TIter& iter,
///         std::size_t size,
///         std::size_t* missingSize,
///         TNextLayerReader&& nextLayerReader)
///     {
///         // read the field's value
///         auto es = field.read(iter, size);
///         if (es != comms::ErrorStatus::Success) {
///             return es;
///         }
///
///         ... // do something with field's value
///         
///         // forward the read to the next layer.
///         return nextLayerReader.read(msgPtr, iter, size - field.length(), missingSize);
///     }
///
///     // Implement write
///     template <typename TMsg, typename TIter, typename TNextLayerWriter>
///     comms::ErrorStatus doWrite(
///         Field& field,
///         const TMsg& msg,
///         TIter& iter,
///         std::size_t size,
///         TNextLayerWriter&& nextLayerWriter) const
///     {
///         // Update field with appropriate value
///         field.value() = ...;
///     
///         // write the field
///         auto es = field.write(iter, size);
///         if (es != comms::ErrorStatus::Success) {
///             return es;
///         }
///     
///         // forward the write to the next layer
///         return nextLayerWriter.write(msg, iter, size - field.length());
///     }
/// };
/// @endcode
/// Note that the third template parameter to the comms::protocol::ProtocolLayerBase
/// base class is the inheriting class itself.
///
/// The comms::protocol::ProtocolLayerBase implements @ref 
/// comms::protocol::ProtocolLayerBase::read() and @ref
/// comms::protocol::ProtocolLayerBase::readFieldsCached() member functions which
/// are actual "read" interface, they invoke the @b doRead() member function implemented
/// the derived layer class, while providing the "nextLayerReader" object to be
/// used to forward the read operation to the next layer. The signature of the
/// @b nextLayerReader.read() function is the same as @ref 
/// comms::protocol::ProtocolLayerBase::read().
///
/// In similar way comms::protocol::ProtocolLayerBase implements @ref 
/// comms::protocol::ProtocolLayerBase::write() and @ref
/// comms::protocol::ProtocolLayerBase::writeFieldsCached() member functions which
/// are actual "write" interface, they invoke the @b doWrite() member function implemented
/// the derived layer class, while providing the "nextLayerWriter" object to be
/// used to forward the read operation to the next layer. The signature of the
/// @b nextLayerWriter.write() function is the same as @ref 
/// comms::protocol::ProtocolLayerBase::write().
///
/// The comms::protocol::ProtocolLayerBase base class defines also "update"
/// interface functions @ref comms::protocol::ProtocolLayerBase::update() and
/// @ref comms::protocol::ProtocolLayerBase::updateFieldsCached(), which in the
/// similar way invoke @b doUpdate(). However, @ref
/// comms::protocol::ProtocolLayerBase class provides a default implementation
/// of @b doUpdate() (see @ref comms::protocol::ProtocolLayerBase::doUpdate()) 
/// member function, which does nothing, just advances the iterator. If there
/// is a need for a custom update functionality, please provide it in you
/// layer class by implementing the custom version of @b doUpdate() member function.
/// @code
/// // Must receive the next layer type as template parameter
/// template <typename TField, typename TNextLayer>
/// class MyLayer : public 
///     comms::protocol::ProtocolLayerBase<
///         TField, 
///         TNextLayer,
///         MyLayer<TField, TNextLayer>
///     >
/// {
/// public:
///     ...
///     template <typename TIter, typename TNextLayerUpdater>
///     comms::ErrorStatus doUpdate(
///         Field& field,
///         TIter& iter,
///         std::size_t size,
///         TNextLayerUpdater&& nextLayerUpdater) const
///     {
///         // Update field with the new value and rewrite it to the output buffer
///         field.value() = ...; 
///         auto es = field.write(iter, size);
///         if (es != comms::ErrorStatus::Success) {
///             return es;
///         }
///
///         // forward the update to the next layer
///         return nextLayerUpdater.update(iter, size - field.length());
///     }
/// };
/// @endcode
/// The signature of the
/// @b nextLayerUpdater.update() function is the same as @ref 
/// comms::protocol::ProtocolLayerBase::update().
/// 
/// If the new layer being implemented is similar to @ref comms::protocol::MsgIdLayer,
/// i.e. creates message objects when id of the message is known, then it must
/// also override (hide) the inherited @ref comms::protocol::ProtocolLayerBase::createMsg() 
/// and implement its own version:
/// @code
/// class MyLayer : public 
///     comms::protocol::ProtocolLayerBase<
///         TField, 
///         TNextLayer,
///         MyLayer<TField, TNextLayer>
///     >
/// {
/// public:
///     ...
///     MsgPtr createMsg(MsgIdParamType id, unsigned idx = 0)
///     {
///         return someInternalFactor.createMsg(id, idx);
///     }
/// };
/// @endcode
///

