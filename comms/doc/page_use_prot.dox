/// @page page_use_prot How to Use Defined Custom Protocol
/// @tableofcontents
/// This page is oriented to client application developers. It provides instructions
/// on how to use protocol defininition after it was developed following
/// @ref page_define_prot instructions. All the examples below will use
/// @b my_protocol namespace for classes that are expectected to be already
/// defined by the custom protocol implementation.
///
/// @section page_use_prot_headers Headers and Libraries
/// The protocol definition as well as @b COMMS library are headers-only. The
/// protocol definition should already include all the required headers from
/// the @b COMMS library. The client application will have to include only relevant
/// headers from the protocol definition.
///
/// @section page_use_prot_error_handling Error Handling
/// The COMMS library is intended to be used in embedded systems (including 
/// bare metal), which means the library does not use exceptions to report errors.
/// The runtime errors are reported via @ref comms::ErrorStatus return values. All
/// pre- and post-conditions are checked using COMMS_ASSERT() macro.
/// It is, just like regular standard @b assert(), is compiled in if @b NDEBUG symbol
/// is not defined. In case the provided condition doesn't hold true, the macro
/// checks whether custom assertion failure behaviour was registered. If yes,
/// the registered custom assertion failure report is invoked, otherwise the
/// standard failure report used by standard @b assert() macro is used. If COMMS
/// library is used in bare metal environment without standard library, the
/// @b NOSTDLIB symbol should be defined. In this case infinite loop is a default
/// assertion failure report behaviour.
///
/// See @ref page_assert for details on how to define custom assertion failure
/// behaviour.  
///
/// @section page_use_prot_interface Defining Message Interface Class
/// The protocol definition is expected to define extendable message interface
/// class pinning only serialisation endian and numeric message ID type (most
/// probably enum).
/// @code
/// namespace my_protocol
/// {
///     // Used IDs definition
///     enum MsgId : std::uint8_t
///     {
///         MsgId_Message1,
///         MsgId_Message2,
///         MsgId_Message3,
///         ...
///     };
///
/// template <typename... TOptions>
/// using Message = 
///     comms::Message<
///         comms::option::BigEndian, // endian
///         comms::option::MsgIdType<MsgId>, // type of message ID
///         TOptions...
///     >;
///
/// } // namespace my_protocol
/// @endcode
/// Such interface class is NOT polymorphic, it defines the following inner types
/// @code
/// namespace my_protocol
/// {
///     
/// class Message : public comms::Message
///     // comms::Field class with the same endian option. 
///     // Can (and should) be provided as a base class to all the
///     // fields.
///     typedef comms::Field<.../* Same endian option*/> Field;
///
///     // Type of the ID, same as the one passed with comms::option::MsgIdType
///     typedef MsgId MsgIdType;
///
///     // Type of the ID, when it is passed as a parameter and/or returned from the function:
///     typedef MsgId MsgIdParamType;
///
/// };
///
/// } // namespace my_protocol
/// @endcode
/// @b Note the existence of @b MsgIdType and @b MsgIdParamType. When the
/// type used for message ID is simple integral one or enum, these types
/// are equal.
/// However, if some other type is used, such as std::string, then @b MsgIdParamType
/// is a const-reference to @b MsgIdType.
///
/// The message interface class may be extended with multiple options, which 
/// automatically add virtual functions, and hence create polymorphic behaviour
/// relevant to the client application.
///
/// In general, all the API functions that are being added to the interface (and described below)
/// use <a href="https://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Non-Virtual_Interface">Non-Virtual Interface</a>
/// idiom:
/// @code
/// class MyMessage
/// {
/// public:
///     void someFunction(...)
///     {
///         ...; // Pre-conditions check and/or other common operations
///         someFunctionImpl(...); // Invocation of polymorphic functionality
///         ...; // Post-conditions check and/or other common operations
///     }
///
/// protected:
///     virtual void someFunctionImpl(...) = 0; // Must be implemented in the derived class
/// };
/// @endcode
/// The polymorphic behaviour is exposed via @b protected virtual functions having
/// the same name, but with @b Impl suffix.
///
/// All the variants of message interface class that are going to be described
/// below are descendants of @ref comms::Message class. Please refer to the
/// documentation of the latter for detailed info on the described functions and
/// their parameters.
///
/// @subsection page_use_prot_interface_id_retrieve Polymorphic Retrieval of Message ID
/// When there is a need to be able to polymorphically retrieve message ID,
/// the comms::option::IdInfoInterface option needs to be used. Note, that this
/// option requires presence of @ref comms::option::MsgIdType (which is expected to
/// be used in protocol definition) to specify type
/// of the message ID in order to work properly.
/// @code
/// using MyMessage =
///     my_protocol::Message<
///         comms::option::IdInfoInterface,
///         ...
///     >;
/// @endcode
/// It adds the following functions:
/// @code
/// class MyMessage
/// {
/// public:
///     // API function to retrieve ID of the function
///     MsgIdParamType getId() const
///     {
///         return getIdImpl();
///     }
///
/// protected:
///     virtual MsgIdParamType getIdImpl() const = 0; // Automatically implemented in the actual message class
/// }
/// @endcode
/// The usage of comms::option::IdInfoInterface without comms::option::MsgIdType
/// will be ignored, and @b getId() as well as @b getIdImpl() member functions
/// won't be created.
///
/// The @ref comms::Message interface class defines @ref comms::Message::hasGetId()
/// static constexpr member function, which may be used at compile time to 
/// determine whether the @ref comms::option::IdInfoInterface option has been used, i.e. 
/// the message interface class defines mentioned earlier
/// functions.
///
/// @subsection page_use_prot_interface_read Polymorphic Read of Payload (Deserialisation)
/// If the implementation requires polymorphic read and process of input messages, the @b read()
/// operation needs to be added to the interface. It is achieved by using 
/// @ref comms::option::ReadIterator option to provide a type of the iterator that
/// is going to be used for reading:
/// @code
/// using MyMessage = 
///     my_protocol::Message<
///         ...
///         comms::option::ReadIterator<const std::uint8_t*>,
///         ...
///     >;
/// @endcode
/// As the result the interface class defines the following types and functions:
/// @code
/// class MyMessage
/// {
/// public:
///     // Type of the the iterator used for reading, the same as provided with
///     // comms::option::ReadIterator option.
///     typedef ... ReadIterator;
///
///     // API function to perform read
///     comms::ErrorStatus read(ReadIterator& iter, std::size_t len)
///     {
///         return readImpl(iter, len);
///     }
///
/// protected:
///     // Expected to be overriden in the derived class.
///     virtual comms::ErrorStatus readImpl(ReadIterator& iter, std::size_t len) 
///     {
///         return comms::ErrorStatus::NotSupported;
///     }
/// }
/// @endcode
/// Please @b note, that COMMS library doesn't impose any restrictions on
/// how the input data is collected and stored. It is a responsibility of the 
/// @b caller to allocate and maintain the input buffer, while providing only an 
/// iterator for read operation. @n
/// Also @b note, that iterator is passed by reference, which allows advancing 
/// operator when read operation is performed. @n
/// For example:
/// @code
/// std::size_t readMessage(MyMessage& msg, const std::uint8_t* buf, std::size_t len)
/// {
///     MyMessage::ReadIterator readIter = buf;
///     auto es = msg->read(readIter, len); // readIter is advanced in the read operation
///     if (es != comms::ErrorStatus::Success) {
///         ... // Report and handle error
///         return 0U; 
///     }
///     
///     // Report number of processed bytes from buffer:
///     auto bytesCount = std::distance(MyMessage::ReadIterator(buf), readIter);
///     return bytesCount;
/// }
/// @endcode
/// The @ref comms::Message interface class defines @ref comms::Message::hasRead()
/// static constexpr member function, which may be used at compile time to 
/// determine whether the @ref comms::option::ReadIterator option has been used, i.e. 
/// the message interface class defines mentioned earlier
/// types and functions.
///
/// @subsection page_use_prot_interface_write Polymorphic Write of Payload (Serialisation)
/// If the implementation requires polymorphic serialisation of the messages and sending them over I/O
/// link, the @b write() operation needs to be added to the interface. It is 
/// achieved by using  comms::option::WriteIterator option to provide a type of 
/// the iterator that is going to be used for writing:
/// @code
/// using MyMessage = 
///     my_protocol::Message<
///         ...
///         comms::option::WriteIterator<std::back_insert_iterator<std::vector<std::uint8_t> > >,
///         ...
///     >;
/// @endcode
/// As the result the interface class defines the following types and functions:
/// @code
/// class MyMessage
/// {
/// public:
///     // Type of the the iterator used for writing, the same as provided with
///     // comms::option::WriteIterator option.
///     typedef ... WriteIterator;
///
///     // API function to perform write
///     comms::ErrorStatus write(WriteIterator& iter, std::size_t len)
///     {
///         return writeImpl(iter, len);
///     }
///
/// protected:
///     // Expected to be overriden in the derived class.
///     virtual comms::ErrorStatus writeImpl(WriteIterator& iter, std::size_t len)
///     {
///         return comms::ErrorStatus::NotSupported;
///     }
/// }
/// @endcode
/// Please @b note, that COMMS library doesn't impose any restrictions on
/// storage type for the output buffer. It is a responsibility of the 
/// @b caller to allocate and maintain the output buffer, while providing only an 
/// iterator for write operation. In the example above the output buffer
/// is chosen to be @b std::vector<std::uint8_t> and the write operation will
/// be performed using @b push_back() calls on this vector (due to @b std::back_insert_iterator
/// being chosen as @b WriteIterator). @n
/// Also @b note, that iterator is passed by reference, which allows advancing 
/// operator when write operation is performed. 
///
/// The @ref comms::Message interface class defines @ref comms::Message::hasWrite()
/// static constexpr member function, which may be used at compile time to 
/// determine whether the @ref comms::option::WriteIterator option has been used, i.e. 
/// the message interface class defines mentioned earlier
/// types and functions.
///
/// @subsection page_use_prot_interface_length Polymorphic Serialisation Length Retrieval
/// Sometimes it may be needed to polymorphically retrieve the serialisation length of the message
/// in order to be able to reserve or allocate enough space for output buffer.
/// The COMMS library provides comms::option::LengthInfoInterface option that
/// adds @b length() member function to the interface.
/// @code
/// using MyMessage = 
///     my_protocol::Message<
///         ...
///         comms::option::LengthInfoInterface,
///         ...
///     >;
/// @endcode
/// This option adds the following functions to the interface definition:
/// @code
/// class MyMessage
/// {
/// public:
///     // Retrieve the serialisation length
///     std::size_t length() const
///     {
///         return lengthImpl();
///     }
///
/// protected:
///     virtual std::size_t lengthImpl() const = 0; // Implemented in the derived class
/// };
/// @endcode
/// The @ref comms::Message interface class defines @ref comms::Message::hasLength()
/// static constexpr member function, which may be used at compile time to 
/// determine whether the @ref comms::option::LengthInfoInterface option has been used, i.e. 
/// the message interface class defines mentioned earlier
/// functions.
///
/// @subsection page_use_prot_interface_valid Polymorphic Validity Check
/// Sometimes it may be needed to be able to check whether the message contents
/// (fields) have valid values. The COMMS library provides comms::option::ValidCheckInterface
/// option that adds @b valid() member function to the interface:
/// @code
/// using MyMessage =
///     my_protocol::Message<
///         ...
///         comms::option::ValidCheckInterface,
///         ...
///     >;
/// @endcode
/// This option adds the following functions to the interface definition:
/// @code
/// class MyMessage
/// {
/// public:
///     // Retrieve the serialisation length
///     bool valid() const
///     {
///         return validImpl();
///     }
///
/// protected:
///     virtual bool validImpl() const
///     {
///         return true; // By default all messages are valid, can be overridden in derived class.
///     }
/// };
/// @endcode
/// The @ref comms::Message interface class defines @ref comms::Message::hasValid()
/// static constexpr member function, which may be used at compile time to 
/// determine whether the @ref comms::option::ValidCheckInterface option has been used, i.e. 
/// the message interface class defines mentioned earlier
/// functions.
///
/// @subsection page_use_prot_interface_handle Polymorphic Dispatch Message for Handling
/// When new data arrives on I/O link, it's transport framing is going to
/// be processed (described in detailed in @ref page_use_prot_transport section below).
/// and new message object is going to be created. It's going to be returned
/// as a smart pointer (std::unique_ptr) to the defined interface class (@b MyMessage).
/// The actual type of this message object needs to be recognised and message
/// properly handled. Using simple
/// switch statement on message ID (returned by @b getId() interface function)
/// can be very @b INEFFICIENT. The COMMS library provides much more efficient way
/// to dispatch messages to appropriate handler. 
///
/// The handler class needs to be forward declared and passed
/// to the definition of @b MyMessage interface via comms::option::Handler option.
/// @code
/// // Forward declaration
/// class MyHandler;
///
/// using MyHandler = 
///     my_protocol::Message<
///         ...
///         comms::option::Handler<MyHandler>,
///         ...
///     >;
/// @endcode
/// When this option is used the @b MyMessage will define the following interface
/// types and functions:
/// @code
/// class MyMessage
/// {
/// public:
///     // The same type as passed via comms::option::Handler option     
///     typedef ... Handler;
///
///     // Return type of the dispatch function, which is the same as return type of
///     // every Handler::handle() member function
///     typedef ... DispatchRetType;
///
///     // Dispatch this message to handler
///     DispatchRetType dispatch(Handler& handler)
///     {
///         return dispatchImpl(handler);
///     }
///
/// protected:
///     virtual DispatchRetType dispatchImpl(Handler& handler) = 0; // Must be implemented in the derived class
/// };
/// @endcode
/// More details about polymorphic dispatching and handling will be provided 
/// below in @ref page_use_prot_handling section.
///
/// The @ref comms::Message interface class defines @ref comms::Message::hasDispatch()
/// static constexpr member function, which may be used at compile time to 
/// determine whether the @ref comms::option::Handler option has been used, i.e. 
/// the message interface class defines mentioned earlier
/// types and functions.
///
/// @subsection page_use_prot_interface_refresh Keeping Message Contents in a Consistent State
/// Some communication protocol may define fields that depend on other fields.
/// For example, bits in a bitmask field may be used to define whether some
/// optional fields exist. Or the information about amount of elements in 
/// the list to follow may reside in an independent numeric field. @n 
/// After updating such fields directly, using the interface of the message object,
/// the message contents may end up being in an inconsistent (or invalid) state.
/// There may be a need to polymorphically normalise the state of the message object. The
/// COMMS library provides comms::option::RefreshInterface option, that adds
/// @b refresh() member function to the message interface.
/// @code
/// using MyMessage = 
///     comms::Message<
///         ...
///         comms::option::RefreshInterface,
///         ...
///     >;
/// @endcode
/// This option adds the following functions to the interface definition:
/// @code
/// class MyMessage
/// {
/// public:
///     // Refresh message contents
///     bool refresh()
///     {
///         return refreshImpl();
///     }
///
/// protected:
///     virtual bool refreshImpl()
///     {
///         return false;
///     }
/// };
/// @endcode
/// Note, that the @b refresh() member function returns boolean value, which
/// is expected to be @b true in case at least one of the internal fields has
/// been updated, and @b false if message state remains unchanged. @n
/// Also note, that interface provide default implementation of @b refreshImpl()
/// virtual function. The message object that require proper "refresh" functionality
/// may just override it with proper implementation.
///
/// The @ref comms::Message interface class defines @ref comms::Message::hasRefresh()
/// static constexpr member function, which may be used at compile time to 
/// determine whether the @ref comms::option::RefreshInterface option has been used, i.e. 
/// the message interface class defines mentioned earlier
/// functions.
///
/// @subsection page_use_prot_interface_summary Interface Options Summary
/// All the options introduced above can be used in any order. They can also
/// be repeated multiple times. However, the option that was defined first takes
/// priority over (or overrides) the same option defined later. @n 
/// For example, the definition below defines @b WriteIterator to be
/// <b>std::uint8_t*</b>, because it was defined with first 
/// comms::option::WriteIterator option:
/// @code
/// using MyMessage = 
///     my_protocol::Message<
///         ...
///         comms::option::WriteIterator<std::uint8_t*>, 
///         ...
///         comms::option::WriteIterator<std::back_insert_iterator<std::vector<std::uint8_t> >,
///         ...
///     >;
/// @endcode  
/// The definition below gives a full interface of all
/// the introduced functions: @b getId(), @b read(), @b write(), @b dispatch(),
/// @b length(), @b valid(), and @b refresh().
/// @code
/// using MyMessage = my_protocol::Message<
///     comms::option::IdInfoInterface, // Add an ability to retrieve message ID value
///     comms::option::ReadIterator<const std::uint8_t*>, // Use const std::uint8_t* as iterator for reading
///     comms::option::WriteIterator<std::uint8_t*>, // Use std::uint8_t* as iterator for writing
///     comms::option::Handler<MyHandler>, // My MyHandler class declared earlier as a handler for messages
///     comms::option::LengthInfoInterface, // Add an ability to retrieve serialisation length
///     comms::option::ValidCheckInterface, // Add an ability to check contents validity
///     comms::option::RefreshInterface  // Add an ability to refresh message contents
/// >;
/// @endcode
///
/// @section page_use_prot_messages Protocol Messages
/// The protocol messages are expected to be defined as template classes, receiving
/// at least one template parameter, which specifies the application specific interface 
/// class. For example
/// @code
/// namespace my_protocol
/// {
/// 
/// namespace message
/// {
///
/// template <typename TBase>
/// class Message1 : public
///     comms::MessageBase<
///         TBase,
///         ...
///     >
/// {
///     ...
/// };
///
/// } // namespace message
///
/// } // namespace my_protocol
/// @endcode
/// The interface class that was defined for the application (@b MyMessage) needs
/// to be passed as @b TBase template parameter. The defined message class 
/// extends @ref comms::MessageBase, which in turn extends provided interface
/// class @b TBase, which in turn extends @ref comms::Message. The inheritence
/// hierarchy may look like this:
/// @diafile message_class_hierarchy.dia
///
/// Due to the fact that every protocol message class extends @ref comms::MessageBase,
/// the detailed documentation on available member types and functions
/// can be viewed on @ref comms::MessageBase reference page.
///
/// All the protocol message classes implement non-virtual functions that may be
/// used to implement polymorphic behavior. These function has the same name as
/// described earlier interface, but start with @b do* prefix.
///
/// @li @b doRead() - implements message read functionality (see @ref comms::MessageBase::doRead())
/// @li @b doWrite() - implements message write functionality (see @ref comms::MessageBase::doWrite())
/// @li @b doLength() - implements message serialisation length calculation (see @ref comms::MessageBase::doLength())
/// @li @b doValid() - implements message contents validity check (see @ref comms::MessageBase::doValid())
/// @li @b doRefresh() - implements bringing message to a consistent state (see @ref comms::MessageBase::doRefresh())
///
/// Based on the requested polymorphic functionality, the @b comms::MessageBase
/// class automatically implements virtual @b *Impl() member functions (but only when needed).
/// @code
/// namespace my_protocol
/// {
/// 
/// namespace message
/// {
///
/// template <typename TBase>
/// class Message1 : public
///     comms::MessageBase<
///         TBase,
///         ...
///     >
/// {
/// public:
///     template <typename TIter>
///     comms::ErrorStatus doRead(TIter& iter, std::size_t len) {...}
///
///     template <typename TIter>
///     comms::ErrorStatus doWrite(TIter& iter, std::size_t len) const {...}
///
///     ...
/// protected:
///     virtual comms::ErrorStatus readImpl(ReadIterator& iter, std::size_t len)
///     {
///         return doRead(iter, len);
///     }
///
///     virtual comms::ErrorStatus writeImpl(WriteIterator& iter, std::size_t len) const
///     {
///         return doWrite(iter, len);
///     }
///
///     ...
/// };
///
/// } // namespace message
///
/// } // namespace my_protocol
/// @endcode
/// Such architecture allows usage of non-virtual functions when actual type
/// of the message is known. For example
/// @code
/// template <typename TMsg>
/// void writeMessage(const TMsg& msg)
/// {
///     auto es = msg.doWrite(...);
///     ...
/// }
/// @endcode
/// and using polymorphic behaviour when not
/// @code
/// void writeMessage(const MyMessage& msg)
/// {
///     auto es = msg.write(...);
///     ...
/// }
/// @endcode
/// Every message has zero or more fields, which are stored in @b std::tuple
/// as private members of @ref comms::MessageBase. The access to the fields
/// can be obtained using @b fields() member function (see @ref comms::MessageBase::fields()).
///
/// However, every message that has at least one field is expected to use
/// @ref COMMS_MSG_FIELDS_ACCESS() macro to provide names to inner fields.
/// @code
/// namespace my_protocol
/// {
/// 
/// namespace message
/// {
///
/// template <typename TBase>
/// class Message1 : public
///     comms::MessageBase<
///         TBase,
///         ...
///     >
/// {
/// public:
///     COMMS_MSG_FIELDS_ACCESS(value1, value2, value3);
///     ...
/// };
///
/// } // namespace message
///
/// } // namespace my_protocol
/// @endcode
/// It is equivalent of having the following types and member functions defined.
/// @code
/// namespace my_protocol
/// {
/// 
/// namespace message
/// {
///
/// template <typename TBase>
/// class Message1 : public
///     comms::MessageBase<
///         TBase,
///         ...
///     >
/// {
/// public:
///     enum FieldIdx
///     {
///         FieldIdx_value1,
///         FieldIdx_value2,
///         FieldIdx_value3,
///         FieldIdx_numOfValues
///     }
///
///     // Access the "value1" field
///     auto field_value1() -> decltype(std::get<FieldIdx_value1>(fields()))
///     {
///         return std::get<FieldIdx_value1>(fields());
///     }
///
///     // Access the "value1" field (const variant)
///     auto field_value1() const -> decltype(std::get<FieldIdx_value1>(fields()))
///     {
///         return std::get<FieldIdx_value1>(fields());
///     }
///
///     // Access the "value2" field
///     auto field_value2() -> decltype(std::get<FieldIdx_value2>(fields()))
///     {
///         return std::get<FieldIdx_value2>(fields());
///     }
///
///     // Access the "value2" field (const variant)
///     auto field_value2() const -> decltype(std::get<FieldIdx_value2>(fields()))
///     {
///         return std::get<FieldIdx_value2>(fields());
///     }
///
///     // Access the "value3" field
///     auto field_value3() -> decltype(std::get<FieldIdx_value3>(fields()))
///     {
///         return std::get<FieldIdx_value3>(fields());
///     }
///
///     // Access the "value3" field (const variant)
///     auto field_value3() const -> decltype(std::get<FieldIdx_value3>(fields()))
///     {
///         return std::get<FieldIdx_value3>(fields());
///     }
/// };
///
/// } // namespace message
///
/// } // namespace my_protocol
/// @endcode
/// As the result every message field can be accessed by index
/// @code
/// using MyMessage1 = my_protocol::Message1<MyMessage>;
/// MyMessage1 msg;
/// auto& msg1Fields = msg.fields(); // access to std::tuple of message fields.
/// auto& value1Field = std::get<MyMessage1::FieldIdx_value1>(msg1Fields);
/// auto& value2Field = std::get<MyMessage1::FieldIdx_value2>(msg1Fields);
/// auto& value2Field = std::get<MyMessage1::FieldIdx_value2>(msg1Fields);
/// @endcode
/// or by name
/// @code
/// auto& value1Field = msg.field_value1();
/// auto& value2Field = msg.field_value2();
/// auto& value2Field = msg.field_value3();
/// @endcode
///
/// @section page_use_prot_fields Message Fields
/// In order to continue with the tutorial, it is paramount to understand a 
/// concept of @b fields, which are abstractions around value storage primitives and/or objects, 
/// such as integral values, floating point values, strings, arrays, etc..
/// Every @b field class is defined in @ref comms::field namespace and 
/// exposes predefined interface in order to
/// make template meta-programming as easy as possible. As an example let's
/// take a look at @ref comms::field::IntValue class which is used to 
/// define integral value field.
/// @code
/// template <typename TBase, typename T, typename... TOptions>
/// class comms::field::IntValue : public TBase
/// {
/// public:
///     // Define inner storage type
///     using ValueType = T;
///     
///     // Get access to the stored value
///     ValueType& value() { return m_value; }
///     const ValueType& value() const { return m_value; }
///
///     // Read
///     template <typename TIter>
///     comms::ErrorStatus read(TIter& iter, std::size_t len) {...}
///
///     // Write
///     template <typename TIter>
///     comms::ErrorStatus write(TIter& iter, std::size_t len) const {...}
///
///     // Serialisation length
///     std::size_t length() const {...}
///
///     // Validity of the value
///     bool valid() const {...}
///
///     // Bring field's contents into a consistent state
///     bool refresh() {...}
///
/// private:
///     ValueType m_value;
/// }
/// @endcode
/// The main things to note are that every field definition class:
/// @li receives its base class as the first 
///     template parameter. It is expected to be a variant of @ref
///     comms::Field with @ref comms::option::BigEndian or @ref 
///     comms::option::LittleEndian option to specify the serialisation endian.
///     It may be inner @b Field type of @b MyMessage interface class defined
///     earlier (@b MyMessage::Field - documented as @ref comms::Message::Field)
/// @li exhibits some default behaviour which can be modified by
///     passing various options from @ref comms::option namespace as additional template
///     parameters. The options that define how field is serialised are expected
///     to be used as part of protocol definition. The protocol definition is
///     also expected to allow passing extra options that are relevant to application
///     environment and/or behaviour (such as modifying the default storage type).
/// @li defines @b ValueType inner value storage
///     type and provides @b value() member functions to access the stored value.
/// @li provides @b read() and @b write() member functions to read and write the 
///     inner value given the iterator used for reading / writing and available
///     length of the buffer.
/// @li has @b length() member function to report how many bytes are required to
///     serialise currently stored value.
/// @li provides @b valid() member function to check whether the stored value is
///     valid (within expected range of values).
/// @li has @b refresh() member function to bring its contents to consistent / valid
///     state when required.
///
/// Also note that all the member function are NON-virtual, i.e. the field 
/// abstractions do not have polymorphic behaviour.
///
/// The most important member function to a client application is @b value().
/// It allows access to the stored value. Note, that the stored value is accessed
/// by reference. It allows both get and set operations:
/// @code
/// auto myFieldValue = myField.value();
/// myField.value() = 5U;
/// @endcode
/// Other member functions are of lesser importance to the client application, 
/// they are used by the protocol definition itself to properly (de)serialise
/// message contents and provide other useful functionality.
///
/// The available fields abstractions are:
/// @li @ref comms::field::IntValue - used to define @ref page_use_prot_fields_int_value
/// @li @ref comms::field::EnumValue - used to define @ref page_use_prot_fields_enum_value
/// @li @ref comms::field::BitmaskValue - used to define @ref page_use_prot_fields_bitmask_value
/// @li @ref comms::field::Bitfield - used to define @ref page_use_prot_fields_bitfield
/// @li @ref comms::field::Bundle - used to define @ref page_use_prot_fields_bundle
/// @li @ref comms::field::ArrayList - used to define @ref page_use_prot_fields_array_list
/// @li @ref comms::field::String - used to define @ref page_use_prot_fields_string
/// @li @ref comms::field::FloatValue - used to define @ref page_use_prot_fields_fp_value
/// @li @ref comms::field::Optional - used to define @ref page_use_prot_fields_optional
/// @li @ref comms::field::Variant - used to define @ref page_use_prot_fields_variant
///
/// @subsection page_use_prot_fields_int_value Integral Value Fields
/// Integral value fields are defined using @ref comms::field::IntValue class.
/// Its inner @b ValueType type is the same as second template parameter. Most
/// integral value fields are defined and used "as-is"
/// @code
/// // base class for all the fields, usually defined by the protocol definition library
/// using MyFieldBase = comms::Field<comms::option::BigEndian>
///
/// // definition of integral field
/// using MyIntField = 
///     comms::field::IntValue<
///         MyFieldBase, // base class for all the fields, defined by the protocol definition library
///         std::uint16_t
///     >;
///
/// // usage of the field
/// MyIntField field;
/// field.value() = 5; // serialised as "00 05"
/// @endcode
/// Some field's definitions may use @ref comms::option::NumValueSerOffset
/// option, which adds predefined offset to the field before serialising and
/// subtracts it before deserialising. Classic example would be having a "year"
/// information, but serialised as offset from year @b 2000 with a single byte.
/// Such field may be defined as following:
/// @code
/// using YearField = 
///     comms::field::IntValue<
///         MyFieldBase, 
///         std::int16_t, 
///         comms::option::FixedLength<1>,
///         comms::option::NumValueSerOffset<-2000>
///     >;
/// @endcode
/// @b NOTE, that while serialisation takes only 1 byte, the client application
/// will use full year number without worrying about added / removed offset
/// @code
/// YearField field;
/// field.value() = 2018; // serialised as 0x12;
/// @endcode
/// Some protocols may exchange floating point values by serialising them as 
/// integral ones. For example, multiply the floating point value by 1000 before
/// the serialisation, and upon reception divide the received value by 1000 to 
/// get the floating point one. Such fields will be defined using @ref
/// comms::field::IntValue type with using @ref comms::option::ScalingRatio
/// option
/// @code
/// using MyFpField = 
///     comms::field::IntValue<
///         MyFieldBase, // base class for all the fields, defined by the protocol definition library
///         std::int32_t,
///         comms::option::ScalingRatio<1, 1000>
///     >;
/// @endcode
/// The inner value of such field is integral one. However, there are
/// @ref comms::field::IntValue::getScaled() and @ref comms::field::IntValue::setScaled()
/// member functions that allow get and set original floating point value without
/// worrying what math operation needs to be performed.
/// @code
/// MyFpField field;
/// field.setScaled(1.3f);
/// assert(field.value() == 1300); 
/// auto asDouble = field.getScaled<double>(); // equivalent to 1.3
/// @endcode
/// In addition to @b scaling, the @b COMMS library also provides an ability
/// to specify @b units. For example, some protocol may define distance in
/// @b 1/10 of the @b millimetres. The definition of such field may look like
/// this
/// @code
/// using MyDistance = 
///     comms::field::IntValue<
///         MyFieldBase,
///         std::int32_t,
///         comms::option::ScalingRatio<1, 10>,
///         comms::option::UnitsMillimeters         
/// @endcode
/// The @b COMMS library provides a set of units conversion functions in
/// @ref comms::units namespace. When using the provided conversion function the application developer
/// doesn't need to remember the original units and/or scaling factor. The @b COMMS library
/// does all the math. It also prevents (at compile time) usage of wrong conversion
/// functions, say calculating time (@b milliseconds), when specified units are 
/// @b distance (@b millimetres).
/// @code
/// MyDistance field; 
/// comms::units::setMeters(field, 1.2345);
/// std::cout << "Distance in 1/10 of mm:" << field.value() << std::endl; // prints 12345
/// std::cout << "Distance in mm" << comms::units::getMillimeters<double>(field); // prints 1234.5
/// std::cout << "Distance in cm" << comms::units::getCentimeters<double>(field); // prints 123.45
/// @endcode
/// By default, When @ref comms::field::IntValue field is constructed, the inner
/// value is constructed to be 0. However, the field definition may use
/// @ref comms::option::DefaultNumValue option to specify some other value
/// @code
/// // definition of integral field
/// using MyIntField = 
///     comms::field::IntValue<
///         MyFieldBase, // base class for all the fields, defined by the protocol definition library
///         std::uint16_t,
///         comms::option::DefaultNumValue<25>
///     >;
///
/// MyIntField field;
/// assert(field.value() == 25);
/// @endcode
///
/// @subsection page_use_prot_fields_enum_value Enum Value Fields
/// The @b enum values are defined using @ref comms::field::EnumValue class. It
/// is very similar to @ref page_use_prot_fields_int_value. The main difference,
/// that second template parameter as well as inner @b ValueType type is @b enum.
/// The @b enum can be scoped (enum class) or regular (just enum).
/// @code
/// enum class SomeEnumVal : std::uint8_t
/// {
///     Val1,
///     Val2,
///     Val3,
///     NumOfValues
/// };
///
/// using SomeEnumField = 
///     comms::field::EnumValue<
///         MyFieldBase,
///         SomeEnumVal,
///         comms::option::ValidNumValueRange<0, (int)SomeEnumVal::NumOfValues - 1>,
///         comms::option::DefaultNumValue<(int)SomeEnumVal::Val3>
///     >;
///
/// SomeEnumField field;
/// assert(field.value() == SomeEnumVal::Val3); // initialised by default to Val3;
/// field.value() = SomeEnumVal::Val2;
/// @endcode 
///
/// @subsection page_use_prot_fields_bitmask_value Bitmask Value Fields
/// Bitmasks (or bitsets) are also numeric values where every bit has separate,
/// independent meaning. Such fields are defined using @ref comms::field::BitmaskValue
/// class. 
/// @code
/// struct MyBitmask : public 
///     comms::field::BitmaskValue<
///         MyFieldBase, 
///         comms::option::FixedLength<1>,
///         comms::option::BitmaskReservedBits<0x2, 0> // Second bit is reserved and must be 0
///     >
/// {
///     ...
/// };
/// @endcode
/// The field definition will use @ref comms::option::FixedLength option in
/// order to specify its serialisation length. The inner @b ValueType type will
/// be calculated automatically and defined as one of the unsigned types: 
/// @b std::uint8_t, @b std::uint16_t, @b std::uint32_t, or @b std::uint64_t.
/// The usage of @ref comms::option::BitmaskReservedBits option will mark 
/// certain bits as "reserved". It influences only validity check functionality
/// (see @ref comms::field::BitmaskValue::valid()). If any of the reserved bits
/// doesn't have an expected value, the call to @b valid() member function will
/// return @b false.
///
/// The bitmask field definition is also expected to use @ref COMMS_BITMASK_BITS()
/// and @ref COMMS_BITMASK_BITS_ACCESS() macros to provide names for the bits
/// and generate convenience access function. If bit names are sequential, i.e. start
/// from bit @b 0, and go up without any holes in the middle, then single
/// @ref COMMS_BITMASK_BITS_SEQ() macro can be used instead achieving the same 
/// effect.
/// @code
/// struct MyBitmask : public
///     comms::field::BitmaskValue<
///         MyFieldBase, 
///         comms::option::FixedLength<1>,
///         comms::option::BitmaskReservedBits<0x2, 0> // Second bit is reserved and must be 0
///     >
/// {
///     COMMS_BITMASK_BITS(first, third=2, fourth, fifth, sixth, seventh, eighth);
///     COMMS_BITMASK_BITS_ACCESS(first, third, fourth, fifth, sixth, seventh, eighth);
/// }
/// @endcode
/// is equivalent to defining:
/// @code
/// struct MyBitmask : public
///     comms::field::BitmaskValue<
///         MyFieldBase, 
///         comms::option::FixedLength<1>,
///         comms::option::BitmaskReservedBits<0x2, 0> 
///     >
/// {
///     enum BitIdx 
///     {
///         BitIdx_first,
///         BitIdx_third=2,
///         BitIdx_fourth,
///         BitIdx_fifth,
///         BitIdx_sixth,
///         BitIdx_seventh,
///         BitIdx_eighth,
///         BitIdx_numOfValues
///     }
///
///     bool getBitValue_first() const { return getBitValue(BitIdx_first); }
///     void setBitValue_first(bool val) { setBitValue(BitIdx_first, val); }
///     bool getBitValue_third() const { ... }
///     void setBitValue_third(bool val) { ... }
///     bool getBitValue_fourth() const { ... }
///     void setBitValue_fourth(bool val) { ... }
///     ...
/// }
/// @endcode
/// The generated convenience access functions use existing 
/// @ref comms::field::BitmaskValue::getBitValue() and
/// @ref comms::field::BitmaskValue::setBitValue() member functions.
///
/// It is also possible to set multiple bits at the same time by accessing 
/// the stored value directly
/// @code
/// MyBitmask field;
/// field.value() = 0x81; // Setting first and eighth bits
/// @endcode
///
/// @subsection page_use_prot_fields_bitfield Bitfield Fields
/// Many communication protocols try to pack multiple independent values into
/// a one or several bytes to save traffic on I/O link. For example RS-232 serial port
/// configuration may be defined as following:
///
/// 3 Bits to configure baud rate:
/// |Baud Rate | Serialisation Value|
/// |:--------:|:------------------:|
/// | 9600     | 0                  |
/// | 14400    | 1                  |
/// | 19200    | 2                  |
/// | 28800    | 3                  |
/// | 38400    | 4                  |
/// | 57600    | 5                  |
/// | 115200   | 6                  |
///
/// 2 Bits to configure parity:
/// |Parity    | Serialisation Value|
/// |:--------:|:------------------:|
/// | None     | 0                  |
/// | Odd      | 1                  |
/// | Even     | 2                  |
///
/// 2 Bits to configure stopBits:
/// |Stop Bits     | Serialisation Value |
/// |:------------:|:-------------------:|
/// | One          | 0                   |
/// | One and half | 1                   |
/// | Two          | 2                   |
///
/// 2 Bits to configure flow control:
/// |Flow Control  | Serialisation Value |
/// |:------------:|:-------------------:|
/// | None         | 0                   |
/// | Hardware     | 1                   |
/// | Software     | 2                   |
///
/// The field definition will use @ref comms::field::Bitfield and probably look similar to code below
/// @code
/// enum class Baud {...}
/// enum class Parity {...}
/// enum class StopBits {...}
/// enum class FlowControl {...}
///
/// struct SerialConfigField : public 
///     comms::field::Bitfield<
///         MyFieldBase, 
///         std::tuple<
///             comms::field::EnumValue<MyFieldBase, Baud, comms::option::FixedBitLength<3> >,
///             comms::field::EnumValue<MyFieldBase, Parity, comms::option::FixedBitLength<2> >,
///             comms::field::EnumValue<MyFieldBase, StopBits, comms::option::FixedBitLength<2> >,
///             comms::field::EnumValue<MyFieldBase, FlowControl, comms::option::FixedBitLength<2> >,
///             comms::field::IntValue<MyFieldBase, std::uint8_t, comms::option::FixedBitLength<7> >
///         >
///     >
/// {
///     COMMS_FIELD_MEMBERS_ACCESS(baud, parity, stopBits, flowControl, reserved);
/// }
/// @endcode
/// All the member fields of the @ref comms::field::Bitfield are stored internally 
/// as @b std::tuple, as the result the inner @b ValueType of such field is
/// @b std::tuple of all member fields and call to @ref comms::field::Bitfield::value()
/// member function will give an access to it. 
///
/// The field definition is expected to use @ref COMMS_FIELD_MEMBERS_ACCESS() macro,
/// which will generate @b FieldIdx enum as well as convenience access member 
/// functions. The code becomes equivalent to:
/// @code
/// struct SerialConfigField : public 
///     comms::field::Bitfield<
///         MyFieldBase, 
///         std::tuple<
///             comms::field::EnumValue<MyFieldBase, Baud, comms::option::FixedBitLength<3> >,
///             comms::field::EnumValue<MyFieldBase, Parity, comms::option::FixedBitLength<2> >,
///             comms::field::EnumValue<MyFieldBase, StopBits, comms::option::FixedBitLength<2> >,
///             comms::field::EnumValue<MyFieldBase, FlowControl, comms::option::FixedBitLength<2> >,
///             comms::field::IntValue<MyFieldBase, std::uint8_t, comms::option::FixedBitLength<7> >
///         >
///     >
/// {
///     // Access indices for member fields
///     enum FieldIdx {
///         FieldIdx_baud,
///         FieldIdx_parity,
///         FieldIdx_stopBits,
///         FieldIdx_flowControl,
///         FieldIdx_reserved,
///         FieldIdx_numOfValues
///     };
/// 
///     // Accessor to "baud" field
///     auto field_baud() -> decltype(std::get<FieldIdx_baud>(value()))
///     {
///         return std::get<FieldIdx_baud>(value());
///     }
///
///     // Accessor to const "baud" field
///     auto field_baud() const -> decltype(std::get<FieldIdx_baud>(value()))
///     {
///         return std::get<FieldIdx_baud>(value());
///     }
///
///     // Accessor to "parity" field
///     auto field_parity() -> decltype(std::get<FieldIdx_parity>(value()))
///     {
///         return std::get<FieldIdx_parity>(value());
///     }
///
///     // Accessor to const "parity" field
///     auto field_parity() const -> decltype(std::get<FieldIdx_parity>(value()))
///     {
///         return std::get<FieldIdx_parity>(value());
///     }
///
///     ... // and so on for all other member fields
/// }
/// @endcode
/// Accessing the member field value in such setup, such as "baud" may look
/// like this:
/// @code
/// SerialConfigField configField;
/// configField.field_baud().value() = Baud::Val_115200;
/// @endcode
/// 
/// @subsection page_use_prot_fields_bundle Bundle Fields
/// There are cases when multiple independent fields need to be bundled into
/// a single field and expose the required interface of reading, writing,
/// calculating length, checking field's contents validity, and bringing field's
/// value into a consistent state. It may be required
/// when a message contains sequence (see @ref page_use_prot_fields_array_list) 
/// of such bundles/structs. The COMMS library provides @ref comms::field::Bundle
/// field for this purpose. It is quite similar to @ref comms::field::Bitfield described
/// earlier. The difference is that every member field
/// doesn't specify any length in bits, just bytes. For example:
/// @code
/// enum SomeEnum : std::uint8_t
/// {
///     SomeEnum_Value1,
///     SomeEnum_Value2,
///     SomeEnum_Value3,
///     ...
/// }
///
/// struct MyBundle : public
///     comms::field::Bundle<
///         MyFieldBase,
///         std::tuple<
///             comms::field::IntValue<MyFieldBase, std::int16_t> // 2 bytes int value
///             comms::field::EnumValue<MyFieldBase, SomeEnum>, // 1 byte enum value
///             comms::field::BitmaskValue<MyFieldBase, comms::option::FixedLength<1> > // 1 byte bitmask
///         >
///     >
/// {
///     COMMS_FIELD_MEMBERS_ACCESS(member1, member2, member3);
/// };
/// @endcode
/// Just like with @ref page_use_prot_fields_bitfield, the inner @b ValueType type
/// of such field is a @b std::tuple of member fields, and usage of 
/// @ref COMMS_FIELD_MEMBERS_ACCESS() has exactly the same effect, i.e. generates
/// inner @b FieldIdx enum and convenience access member functions:
/// @code
/// struct MyBundle : public
///     comms::field::Bundle<
///         MyFieldBase,
///         std::tuple<
///             comms::field::IntValue<MyFieldBase, std::int16_t> // 2 bytes int value
///             comms::field::EnumValue<MyFieldBase, SomeEnum>, // 1 byte enum value
///             comms::field::BitmaskValue<MyFieldBase, comms::option::FixedLength<1> > // 1 byte bitmask
///         >
///     >
/// {
///     enum FieldIdx
///     {
///         FieldIdx_member1,
///         FieldIdx_member2,
///         FieldIdx_member3,
///         FieldIdx_numOfValues
///     };
///
///     // Accessor to "member1" field
///     auto field_member1() -> decltype(std::get<FieldIdx_member1>(value()))
///     {
///         return std::get<FieldIdx_member1>(value());
///     }
///
///     // Accessor to const "baud" field
///     auto field_member1() const -> decltype(std::get<FieldIdx_member1>(value()))
///     {
///         return std::get<FieldIdx_member1>(value());
///     }
///
///     // Accessor to "parity" field
///     auto field_member2() -> decltype(std::get<FieldIdx_member2>(value()))
///     {
///         return std::get<FieldIdx_member2>(value());
///     }
///
///     ...
/// };
/// @endcode
///
/// @subsection page_use_prot_fields_array_list Array List Fields
/// Some communication protocols may define messages that transmit sequence
/// of similar fields and/or raw data buffers. To make it easier to handle, the
/// COMMS library provides comms::field::ArrayList field which provide a required
/// interface to properly handle such sequences of data. It supports a
/// sequence of raw bytes
/// @code
/// using MySimpleList = 
///     comms::field::ArrayList<
///         MyFieldBase,
///         std::uint8_t // raw byte type as second template parameter
///     >;
/// @endcode
/// as well as using sequence of any fields defined in comms::field namespace
/// @code
/// using MyComplexList = 
///     comms::field::ArrayList<
///         MyFieldBase,
///         MyBundle // Complex bundle field, defined in previous section 
///     >;
/// @endcode
/// The @b default storage type (inner @b ValueType type) of these fields is
/// @b std::vector of specified type, i.e. it is @b std::vector<std::uint8_t>
/// in case of @b MySimpleList and @b std::vector<MyBundle> in case of
/// @b MyComplexList. Such default storage type may be unsuitable to certain
/// applications, especially for bare-metal ones. The @b COMMS library allows
/// changing it using extra options. The protocol definition is expected to
/// provide a way to pass extra options to such fields. It is explained in
/// @ref page_use_prot_fields_customisation section below in more details.
///
/// Please pay attention, that in case of non-raw data lists, the inner @b std::vector
/// contains fields, not values. As the result access to the stored values 
/// may require a bit of extra function calls:
/// @code
/// MyComplexList list;
/// auto& storageVec = list.value(); // access to std::vector<MyBundle>
/// storageVec.resize(1);
/// auto& firstBundle = storageVec[0]; // access to first MyBundle element
/// auto& firstMember1 = firstBundle.field_member1(); // access to "member1" member of first bundle
/// auto mem1Value = firstMember1.value(); // get the actual value of "member1"
/// @endcode
/// Some protocols may define fixed size lists. In such case lists are defined
/// with usage of @ref comms::option::SequenceFixedSize option. 
/// @code
/// using MyList = 
///     comms::field::ArrayList<
///         MyFieldBase,
///         comms::field::IntValue<MyFieldBase, std::uint16_t>,
///         comms::option::SequenceFixedSize<4>
///     >;
/// @endcode
/// Usage of this option just ensures right amount of elements "on the wire" after
/// the field is serialised, but it doesn't automatically resize inner 
/// storage vector.
/// @code
/// MyList field;
/// assert(field.value().empty()); // vector is empty upon construction
/// @endcode
///
/// @subsection page_use_prot_fields_string String Fields
/// Many protocols have to transfer strings. They are defined using
/// @ref comms::field::String field.
/// @code
/// using MyString = comms::field::String<MyFieldBase>;
/// @endcode
/// It is very similar to comms::field::ArrayList
/// it terms of value storage, read/write operations, and supported options.
/// By default the value is stored as 
/// <a href="http://en.cppreference.com/w/cpp/string/basic_string">std::string</a>.
/// @code
/// MyString myStr;
/// auto& myStrStorage = myStr.value(); // Reference to std::string.
/// @endcode
/// However, there are options that can modify this default behaviour. The
/// protocol definition classes are expected to provide a way to pass extra
/// application specific options to the string field definition. It is explained
/// in more details in @ref page_use_prot_fields_customisation section below.
///
/// Also similar to @ref page_use_prot_fields_array_list, fixed length strings
/// are defined using @ref comms::option::SequenceFixedSize option, and just
/// like with lists it doesn't automatically resize inner string, just ensures
/// right amount of characters "on the wire" when field is serialised.
/// @code
/// using MyFixedString = 
///     comms::field::String<
///         MyFieldBase,
///         comms::option::SequenceFixedSize<32>
///     >;
///
/// MyFixedString field;
/// assert(field.value().empty());
/// @endcode
///
/// @subsection page_use_prot_fields_fp_value Floating Point Value Fields
/// Floating point value fields are defined using @ref comms::field::FloatValue
/// They are very similar to 
/// @ref page_use_prot_fields_int_value, but use @b float or @b double as its 
/// internal storage type. They abstract the IEEE 754 floating point 
/// values, which are serialised "as is" with either big or little endian
/// encoding. The floating point value fields also support 
/// the same scaling and units conversion just like @ref page_use_prot_fields_int_value.
///
/// @subsection page_use_prot_fields_optional Optional Fields
/// Some protocols may define optional fields, which may exist or be missing
/// based on information recorded in other fields. For example there is a
/// "flags" bitmask field which specifies whether the following field exists or
/// missing. The optional field may also be tentative, i.e. if there is enough
/// data in the input buffer it exists, and missing otherwise. The COMMS
/// library provides @ref comms::field::Optional which is a mere wrapper around
/// other fields and provides an ability to set the optional state of the field.
/// @code
/// using OptField = 
///     comms::field::Optional<
///         comms::field::IntValue<MyFieldBase, std::int32_t>
///     >;
/// @endcode
/// The default mode of such field is "tentative".
/// @code
/// OptField field;
/// assert(field.isTentative());
/// @endcode
/// The default mode can be changed using @ref comms::option::ExistsByDefault
/// or @ref comms::option::MissingByDefault options. For example
/// @code
/// using ExistingOptField = 
///     comms::field::Optional<
///         comms::field::IntValue<MyFieldBase, std::int32_t>,
///         comms::option::ExistsByDefault
///     >;
///
/// ExistingOptField field;
/// assert(field.doesExist()); 
/// @endcode
/// @b NOTE, that inner @b ValueType of such field is wrapped actual field and
/// both @ref comms::field::Optional::value() and @ref comms::field::Optional::field()
/// member functions allow to access it. For example:
/// @code
/// OptField field;
/// auto& innerField = field.field(); // or call field.value()
/// innerField.value() = 1234;
/// field.setExists();
/// @endcode
///
/// @subsection page_use_prot_fields_variant Variant Fields
/// Some protocols may require usage of heterogeneous fields or lists of 
/// heterogeneous fields, i.e. the ones that can be of multiple types. Good example
/// would be a list of @b properties, where every property is a key/value pair. The
/// key is a numeric ID of the property, while value can be a numeric field of
/// any length or a string one. Such fields are defined using 
/// @ref comms::field::Variant class. It is very similar to @ref 
/// page_use_prot_fields_bundle, but serves as one big union of provided member
/// fields, i.e. only one can be used at a time. These fields are quite rare
/// and if your protocol defines one, please read @ref sec_field_tutorial_variant
/// tutorial on how to define one, it will explain how to use it as well.
///
/// @subsection page_use_prot_fields_customisation Application Specific Customisation of Fields
///
/// @section page_use_prot_transport Transport Framing
///
/// @section page_use_prot_handling Message Handling
///
/// @section page_use_prot_extra_transport Extra Transport Values
///
/// @section page_use_prot_msg_customisation Application Specific Customisation of Messages
///
/// @section page_use_prot_msg_extension Message Interface Extension
///
///

