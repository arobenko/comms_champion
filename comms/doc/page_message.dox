/// @page page_message_tutorial Messages Tutorial
/// @tableofcontents
/// The communication protocols are all about exchanging @b messages over some
/// I/O link between two or more nodes. This tutorial page goes through and explains
/// every stage in defining messages for any custom communication protocol.
///
/// There are two main stages in defining the protocol messages. The first one
/// is defining the common @ref page_message_tutorial_interface class with 
/// required polymorphic behaviour. The second one is 
/// @ref page_message_tutorial_implementation of the actual messages, that
/// implement necessary virtual functions in defined polymorphic interface.
/// 
/// @section page_message_tutorial_interface Interface
/// The COMMS library provides comms::Message
/// class that must be a base class for all the custom messages that are going
/// to be implemented. It receives variable number of template parameters, which
/// are expected to be functionality extension options (defined in comms::option
/// namespace). These options define the <b>common interface</b> for all the custom
/// messages. 
///
/// Depending on the options provided to the comms::Message, it
/// can define the following public @b polymorphic interface:
/// @li comms::Message::getId() - Retrieval of the ID of the message.
/// @li comms::Message::read() - Read message data from the stream of raw bytes
/// @li comms::Message::write() - Write message data to the output buffer.
/// @li comms::Message::dispatch() - Dispatch message for handling.
/// @li comms::Message::length() - Get number of bytes required to serialise
///     the message having the current state.
/// @li comms::Message::valid() - Check the validity of the message data.
/// @li comms::Message::refresh() - Bring the message contents into a consistent 
///     state.
///
/// In general, all the API functions that are being added to the interface (and described below)
/// use <a href="https://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Non-Virtual_Interface">Non-Virtual Interface</a>
/// idiom:
/// @code
/// class Message
/// {
/// public:
///     void someFunction(...)
///     {
///         ...; // Pre-conditions check and/or other common operations
///         someFunctionImpl(...); // Invocation of polymorphic functionality
///         ...; // Post-conditions check and/or other common operations
///     }
///
/// protected:
///     virtual void someFunctionImpl(...) = 0; // Must be implemented in the derived class
/// };
/// @endcode
/// The polymorphic behaviour is exposed via @b protected virtual functions having
/// the same name, but with @b Impl suffix.
///
/// When defining the common interface class for all the custom protocol messages
/// it is recommended to typedef the comms::Message definition with all the
/// required options:
/// @code
/// typedef comms::Message<.../* Required Options */> MyMessage;
/// @endcode
///
/// If the default interface comms::Message provides is not enough and needs to
/// be extended, then it can easily be done using public inheritance:
/// @code
/// class MyMessage : public comms::Message<...>
/// {
/// public:
///     const char* name() const
///     {
///         return nameImpl();
///     }
///
/// protected:
///     virtual const char* nameImpl() const = 0;
/// };
/// @endcode
///
/// Please @b NOTE, that by default the comms::Message class defines its 
/// destructor as @b virtual if and only if it exhibits a polymorphic behaviour, 
/// i.e. if there is at least one other virtual function defined. There are a couple of
/// ways to change this default behaviour.
/// @li If the definition of the common message interface class using 
///     comms::Message exhibits polymorphic 
///     behaviour (i.e. has other virtual functions), but mustn't define its
///     destructor as @b virtual, use comms::option::NoVirtualDestructor 
///     option in the interface class definition.
///     @code
///     using MyInteface = 
///         comms::Message<
///             ...,
///             comms::option::NoVirtualDestructor
///         >;
///     @endcode
/// @li If the definition of the common interface class using comms::Message 
///     doesn't have any virtual function, but still requires an ability to 
///     be polymorphically deleted, i.e. must have virtual destructor, just 
///     inherit from comms::Message and define the destructor as virtual.
///     @code
///     class MyInterface : public 
///         comms::Message<comms::option::BigEndian, comms::option::MsgIdType<std::uint8_t> >
///     {
///     public:
///         virtual ~MyInterface() = default;
///     };
///     @endcode
///
/// When implementing a custom protocol it is recommended to always define
/// the common message interface in the following way:
/// @code
/// template <typename... TOptions>
/// using MyProtocolMessage = 
///     comms::Message<
///         comms::option::BigEndian, // Fix the endian, usually known up front
///         comms::option::MsgIdType<MsgId>, // Type used to differentiate messages (usually some enum)
///         TOptions... // Extend it with provided options
///     >;
/// @endcode
/// The definition above fixes endian and type used to specify message ID. The
/// variadic @b TOptions parameter allows to choose any polymorphic (virtual)
/// behaviour in the future.
///
/// Let's now review all the other supported options one by one:
/// 
/// @subsection page_message_tutorial_interface_endian Serialisation Endian
/// Most of the messages carry some kind of payload, which needs to be
/// serialised. Usually the protocol uses the same serialisation endian (Big or Little)
/// for all the data in all the messages. When using comms::Message to
/// define interface for all the messages, it is recommended to specify
/// the serialisation endian using comms::option::BigEndian or 
/// comms::option::LittleEndian options. 
/// @code
/// typedef comms::Message<
///     ...
///     comms::option::BigEndian,
///     ...
/// > MyMessage;
/// @endcode
/// If and only if the endian specification option was used, the
/// comms::Message class defines following internal functions and types. 
/// @code
/// class MyMessage
/// {
/// public:
///     // comms::Field class with the same endian option. 
///     // Can (and should) be provided as a base class to all the
///     // fields.
///     typedef comms::Field<.../* Same endian option*/> Field;
///
/// protected:
///     // Read serialised value of type T from input buffer using proper 
///     // serialisation endian.
///     template <typename T, typename TIter>
///     static T readData(TIter& iter);
/// 
///     // Read serialised value of type T from input buffer using proper 
///     // serialisation endian with number of bytes to read specified by the
///     // template parameter TSize.
///     template <typename T, std::size_t TSize, typename TIter>
///     static T readData(TIter& iter);
///
///     // Serialise value into output buffer using proper serialisation endian.
///     template <typename T, typename TIter>
///     static void writeData(T value, TIter& iter);
///
///     // Serialise value into output buffer using proper serialisation endian
///     // with number of bytes to write specified by the template parameter TSize.
///     template <std::size_t TSize, typename T, typename TIter>
///     static void writeData(T value, TIter& iter);
/// };
/// @endcode
/// Every message interface may define read and/or write functionalities
/// (described later), which will have to be implemented in the custom
/// message class. The @b readData() and @b writeData() static member functions
/// are provided for help in this task. @n
/// Also note, the definition of the @b Field internal type. Later this tutorial
/// will present information on using @b fields to define message payload. The 
/// value of every such @b field needs to be serialised/deserialised. The COMMS
/// library provides multiple built-in fields that reside in comms::field
/// namespace and described in details in @ref page_field_tutorial page.
/// Almost every such field will require a variant of comms::Field class to be
/// used as the base class. It is also expected to provide @b readData() and 
/// @b writeData() member functions which can be used to serialise stored value.
/// The internal @b Field type definition inside the
/// @b MyMessage interface class may be used as such.
///
/// The @ref comms::Message interface class defines @ref comms::Message::hasEndian()
/// static constexpr member function, which may be used at compile time to 
/// determine whether the endian specifying option has been used, i.e. 
/// the message interface class defines mentioned earlier
/// types and functions.
///  
/// @subsection page_message_tutorial_interface_id_type Type of Message ID
/// Every message must have an ID. Most communication protocols define it
/// as a numeric value that occupies one or two bytes when serialised. The 
/// best and easiest way to define the ID type is by using @b enum with underlying
/// type specification:
/// @code
/// enum MyMsgId : std::uint8_t
/// {
///     MyMsgId_Message1,
///     MyMsgId_Message2,
///     MyMsgId_Message3,
///     ...
/// }; 
/// @endcode
/// When type, that is going to be used to store ID of the message, is defined
/// it should be passed to the definition of the interface using 
/// comms::option::MsgIdType option:
/// @code
/// typedef comms::Message<
///     ...
///     comms::option::MsgIdType<MyMsgId>,
///     ...
/// > MyMessage;
/// @endcode
/// After using such option the interface class (@b MyMessage) defines the 
/// following types:
/// @code
/// class MyMessage
/// {
/// public:
///     // Type of the ID, same as the one passed with comms::option::MsgIdType
///     typedef ... MsgIdType;
///
///     // Type of the ID, when it is passed as a parameter and/or returned from the function:
///     typedef ... MsgIdParamType;
/// }
/// @endcode
/// @b Note the existence of @b MsgIdType and @b MsgIdParamType. When the
/// type used for message ID is simple integral one or enum, these types
/// are equal.
/// However, if some other type is used, such as std::string, then @b MsgIdParamType
/// is a const-reference to @b MsgIdType.
///
/// The @ref comms::Message interface class defines @ref comms::Message::hasMsgIdType()
/// static constexpr member function, which may be used at compile time to 
/// determine whether the @ref comms::option::MsgIdType option has been used, i.e. 
/// the message interface class defines mentioned earlier
/// types.
///
/// @subsection page_message_tutorial_interface_id_retrieve Polymorphic Retrieval of Message ID
/// When there is a need to be able to polymorphically retrieve message ID,
/// the comms::option::IdInfoInterface option needs to be used in addition
/// to comms::option::MsgIdType. 
/// @code
/// typedef comms::Message<
///     ...
///     comms::option::MsgIdType<MyMsgId>,
///     comms::option::IdInfoInterface,
///     ...
/// > MyMessage;
/// @endcode
/// It adds the following functions:
/// @code
/// class MyMessage
/// {
/// public:
///     // API function to retrieve ID of the function
///     MsgIdParamType getId() const
///     {
///         return getIdImpl();
///     }
///
/// protected:
///     virtual MsgIdParamType getIdImpl() const = 0; // Must be implemented in the derived class
/// }
/// @endcode
/// The usage of comms::option::IdInfoInterface without comms::option::MsgIdType
/// will be ignored, and @b getId() as well as @b getIdImpl() member functions
/// won't be created.
///
/// The @ref comms::Message interface class defines @ref comms::Message::hasGetId()
/// static constexpr member function, which may be used at compile time to 
/// determine whether the @ref comms::option::IdInfoInterface option has been used, i.e. 
/// the message interface class defines mentioned earlier
/// functions.
///
/// @subsection page_message_tutorial_interface_read Polymorphic Read of Payload (Deserialisation)
/// If the implementation requires polymorphic read and process of input messages, the @b read()
/// operation needs to be added to the interface. It is achieved by using 
/// comms::option::ReadIterator option to provide a type of the iterator that
/// is going to be used for reading:
/// @code
/// typedef comms::Message<
///     ...
///     comms::option::ReadIterator<const std::uint8_t*>,
///     ...
/// > MyMessage;
/// @endcode
/// As the result the interface class defines the following types and functions:
/// @code
/// class MyMessage
/// {
/// public:
///     // Type of the the iterator used for reading, the same as provided with
///     // comms::option::ReadIterator option.
///     typedef ... ReadIterator;
///
///     // API function to perform read
///     comms::ErrorStatus read(ReadIterator& iter, std::size_t len)
///     {
///         return readImpl(iter, len);
///     }
///
/// protected:
///     // May be overriden in the derived class.
///     virtual comms::ErrorStatus readImpl(ReadIterator& iter, std::size_t len) 
///     {
///         return comms::ErrorStatus::NotSupported;
///     }
/// }
/// @endcode
/// Please @b note, that COMMS library doesn't impose any restrictions on
/// how the input data is collected and stored. It is a responsibility of the 
/// @b caller to allocate and maintain the input buffer, while providing only an 
/// iterator for read operation. @n
/// Also @b note, that iterator is passed by reference, which allows advancing 
/// operator when read operation is performed. @n
/// For example:
/// @code
/// std::size_t readMessage(MyMessage& msg, const std::uint8_t* buf, std::size_t len)
/// {
///     MyMessage::ReadIterator readIter = buf;
///     auto es = msg->read(readIter, len); // readIter is advanced in the read operation
///     if (es != comms::ErrorStatus::Success) {
///         ... // Report and handle error
///         return 0U; 
///     }
///     
///     // Report number of processed bytes from buffer:
///     auto bytesCount = std::distance(MyMessage::ReadIterator(buf), readIter);
///     return bytesCount;
/// }
/// @endcode
/// The @ref comms::Message interface class defines @ref comms::Message::hasRead()
/// static constexpr member function, which may be used at compile time to 
/// determine whether the @ref comms::option::ReadIterator option has been used, i.e. 
/// the message interface class defines mentioned earlier
/// types and functions.
///
/// @subsection page_message_tutorial_interface_write Polymorphic Write of Payload (Serialisation)
/// If the implementation requires polymorhpic serialisation of the messages and sending them over I/O
/// link, the @b write() operation needs to be added to the interface. It is 
/// achieved by using  comms::option::WriteIterator option to provide a type of 
/// the iterator that is going to be used for writing:
/// @code
/// typedef comms::Message<
///     ...
///     comms::option::WriteIterator<std::back_insert_iterator<std::vector<std::uint8_t> > >,
///     ...
/// > MyMessage;
/// @endcode
/// As the result the interface class defines the following types and functions:
/// @code
/// class MyMessage
/// {
/// public:
///     // Type of the the iterator used for writing, the same as provided with
///     // comms::option::WriteIterator option.
///     typedef ... WriteIterator;
///
///     // API function to perform write
///     comms::ErrorStatus write(WriteIterator& iter, std::size_t len)
///     {
///         return writeImpl(iter, len);
///     }
///
/// protected:
///     // May be overriden in the derived class.
///     virtual comms::ErrorStatus writeImpl(WriteIterator& iter, std::size_t len)
///     {
///         return comms::ErrorStatus::NotSupported;
///     }
/// }
/// @endcode
/// Please @b note, that COMMS library doesn't impose any restrictions on
/// storage type for the output buffer. It is a responsibility of the 
/// @b caller to allocate and maintain the output buffer, while providing only an 
/// iterator for write operation. In the example above the output buffer
/// is chosen to be @b std::vector<std::uint8_t> and the write operation will
/// be performed using @b push_back() calls on this vector (due to @b std::back_insert_iterator
/// being chosen as @b WriteIterator). @n
/// Also @b note, that iterator is passed by reference, which allows advancing 
/// operator when write operation is performed. 
///
/// The @ref comms::Message interface class defines @ref comms::Message::hasWrite()
/// static constexpr member function, which may be used at compile time to 
/// determine whether the @ref comms::option::WriteIterator option has been used, i.e. 
/// the message interface class defines mentioned earlier
/// types and functions.
///
/// @subsection page_message_tutorial_interface_handle Polymorphic Dispatch Message for Handling
/// When new data arrives on I/O link, the <b>Protocol Stack</b>
/// (see @ref mainpage_transport_info) processes
/// the transport information that wraps the message payload, creates the
/// proper message object, based on the message ID information and returns it
/// wrapped in smart pointer (std::unique_ptr) to @b MyMessage
/// interface class. When such pointer is received by outer processing logic, 
/// appropriate  message handling functionality needs to be executed. Using simple
/// switch statement on message ID (returned by @b getId() interface function)
/// can be very @b INEFFICIENT. The COMMS library provides much more efficient way
/// to dispatch messages to appropriate handler. 
///
/// The handler class needs to be forward declared and passed
/// to the definition of @b MyMessage interface via comms::option::Handler option.
/// @code
/// // Forward declaration
/// class MyHandler;
///
/// typedef comms::Message<
///     ...
///     comms::option::Handler<MyHandler>,
///     ...
/// > MyMessage;
/// @endcode
/// When this option is used the @b MyMessage will define the following interface
/// types and functions:
/// @code
/// class MyMessage
/// {
/// public:
///     // The same type as passed via comms::option::Handler option     
///     typedef ... Handler;
///
///     // Return type of the dispatch function, which is the same as return type of
///     // every Handler::handle() member function
///     typedef ... DispatchRetType;
///
///     // Dispatch this message to handler
///     DispatchRetType dispatch(Handler& handler)
///     {
///         return dispatchImpl(handler);
///     }
///
/// protected:
///     virtual DispatchRetType dispatchImpl(Handler& handler) = 0; // Must be implemented in the derived class
/// };
/// @endcode
/// More details about dispatching will be provided below in @ref page_message_tutorial_impl_msg_type
/// section.
///
/// The @ref comms::Message interface class defines @ref comms::Message::hasDispatch()
/// static constexpr member function, which may be used at compile time to 
/// determine whether the @ref comms::option::Handler option has been used, i.e. 
/// the message interface class defines mentioned earlier
/// types and functions.
///
/// @subsection page_message_tutorial_interface_length Polymorphic Serialisation Length Retrieval
/// Sometimes it may be needed to polymorphically retrieve the serialisation length of the message
/// in order to be able to reserve or allocate enough space for output buffer.
/// The COMMS library provides comms::option::LengthInfoInterface option that
/// adds @b length() member function to the interface defined with comms::Message.
/// @code
/// typedef comms::Message<
///     ...
///     comms::option::LengthInfoInterface,
///     ...
/// > MyMessage;
/// @endcode
/// This option adds the following functions to the interface definition:
/// @code
/// class MyMessage
/// {
/// public:
///     // Retrieve the serialisation length
///     std::size_t length() const
///     {
///         return lengthImpl();
///     }
///
/// protected:
///     virtual std::size_t lengthImpl() const = 0; // Must be implemented in the derived class
/// };
/// @endcode
/// The @ref comms::Message interface class defines @ref comms::Message::hasLength()
/// static constexpr member function, which may be used at compile time to 
/// determine whether the @ref comms::option::LengthInfoInterface option has been used, i.e. 
/// the message interface class defines mentioned earlier
/// functions.
///
/// @subsection page_message_tutorial_interface_valid Polymorphic Validity Check
/// Sometimes it may be needed to be able to check whether the message contents
/// (fields) have valid values. The COMMS library provides comms::option::ValidCheckInterface
/// option that adds @b valid() member function to the interface:
/// @code
/// typedef comms::Message<
///     ...
///     comms::option::ValidCheckInterface,
///     ...
/// > MyMessage;
/// @endcode
/// This option adds the following functions to the interface definition:
/// @code
/// class MyMessage
/// {
/// public:
///     // Retrieve the serialisation length
///     bool valid() const
///     {
///         return validImpl();
///     }
///
/// protected:
///     virtual bool validImpl() const
///     {
///         return true; // By default all messages are valid, can be overridden in derived class.
///     }
/// };
/// @endcode
/// The @ref comms::Message interface class defines @ref comms::Message::hasValid()
/// static constexpr member function, which may be used at compile time to 
/// determine whether the @ref comms::option::ValidCheckInterface option has been used, i.e. 
/// the message interface class defines mentioned earlier
/// functions.
///
/// @subsection page_message_tutorial_interface_refresh Keeping Message Contents in a Consistent State
/// Some communication protocol may define fields that depend on other fields.
/// For example, bits in a bitmask field may be used to define whether some
/// optional fields exist. Or the information about amount of elements in 
/// the list to follow may reside in an independent numeric field. @n 
/// After updating such fields directly, using the interface of the message object,
/// the message contents may end up being in an inconsistent (or invalid) state.
/// There must be a way to polymorphically normalise the state of the message object. The
/// COMMS library provides comms::option::RefreshInterface option, that adds
/// @b refresh() member function to the message interface.
/// @code
/// typedef comms::Message<
///     ...
///     comms::option::RefreshInterface,
///     ...
/// > MyMessage;
/// @endcode
/// This option adds the following functions to the interface definition:
/// @code
/// class MyMessage
/// {
/// public:
///     // Refresh message contents
///     bool refresh()
///     {
///         return refreshImpl();
///     }
///
/// protected:
///     virtual bool refreshImpl()
///     {
///         return false;
///     }
/// };
/// @endcode
/// Note, that the @b refresh() member function returns boolean value, which
/// is expected to be @b true in case at least one of the internal fields has
/// been updated, and @b false if message state remains unchanged. @n
/// Also note, that interface provide default implementation of @b refreshImpl()
/// virtual function. The message object that require proper "refresh" functionality
/// may just override it with proper implementation.
///
/// The @ref comms::Message interface class defines @ref comms::Message::hasRefresh()
/// static constexpr member function, which may be used at compile time to 
/// determine whether the @ref comms::option::RefreshInterface option has been used, i.e. 
/// the message interface class defines mentioned earlier
/// functions.
///
/// @subsection page_message_tutorial_interface_extra_transport Extra Transport Values
/// Some protocols may use extra values in their transport information, which
/// may influence the way how message payload is being read and/or message 
/// object being handled. Good example would be having a protocol version, which
/// defines what message payload fields were serialised and which were not (because
/// they were introduced in later version of the protocol).
/// Such extra information needs to be stored in the message object itself.
/// The most straightforward way of achieving this is to define appropriate API
/// functions and member fields in common message interface class:
/// @code
/// class MyMessage : public comms::Message<...>
/// {
/// public:
///     unsigned getVersion() const { return m_version; }
///     void setVersion(unsigned value) { m_version = value; }
/// private:
///     unsigned m_version = 0;
/// @endcode
/// @b HOWEVER, it will require implementation of a custom protocol transport layer
/// (See @ref page_prot_stack_tutorial_new_layers) that reads the required value
/// and re-assigns it to the message object using appropriate API function. The
/// COMMS library has a built-in way to automate such assignments (see 
/// @ref page_prot_stack_tutorial_transport_value section in @ref page_prot_stack_tutorial). 
/// In order to support usage
/// of @ref comms::protocol::TransportValueLayer the message interface class must
/// define "extra transport fields".
///
/// First, such extra transport field(s) must be defined using a field abstraction
/// (see @ref page_field_tutorial) and bundled in @b std::tuple:
/// @code
/// // Base class of all the fields
/// using MyFieldBase = comms::Field<comms::option::BigEndian>;
///
/// // Field describing protocol version.
/// using MyVersionField = comms::field::IntValue<MyFieldBase, std::uint16_t>;
///
/// // Relevant extra transport fields, bundled in std::tuple
/// using MyExtraTransportFields =
///     std::tuple<
///         MyVersionField
///     >;
/// @endcode
///
/// Second, provide the defined tuple to message interface class using 
/// @ref comms::option::ExtraTransportFields option.
/// @code
/// class MyMessage : public
///     comms::Message<
///         ...,
///         comms::option::ExtraTransportFields<MyExtraTransportFields>
///     >
/// {
/// };
/// @endcode
/// It is equivalent to having the following public interface defined:
/// @code
/// class MyMessage
/// {
/// public:
///     // Type of extra fields
///     using TransportFields = MyExtraTransportFields;
///
///     // Accessors for defined transport fields
///     TransportFields& transportFields() { return m_transportFields; }
///     const TransportFields& transportFields() const { return m_transportFields; }
///
/// private:
///     TransportFields m_transportFields;
/// };
/// @endcode
/// An access to the version information, given a reference to the message object
/// will look like this:
/// @code
/// void handle(MyMessage& msg)
/// {
///     // Access to tuple of extra transport fields
///     auto& extraTransportFields = msg.transportFields();
///
///     // Access the version field
///     auto& versionField = std::get<0>(extraTransportFields);
///
///     // Retrieve the version numeric value
///     auto versionValue = versionField.value();
///
///     ... // do something with version information
/// }
/// @endcode
/// The version information may be accessed in the same way when implementing
/// @ref page_message_tutorial_impl_custom_read and acted accordingly.
///
/// @b NOTE, that example above accesses the index of the field within the holding
/// tuple. For convenience, the COMMS library defines 
/// COMMS_MSG_TRANSPORT_FIELDS_ACCESS() macro which allows provding meaningful
/// names to the extra transport fields:
/// @code
/// class MyMessage : public
///     comms::Message<
///         ...,
///         comms::option::ExtraTransportFields<MyExtraTransportFields>
///     >
/// {
/// public:
///     COMMS_MSG_TRANSPORT_FIELDS_ACCESS(version)
/// };
/// @endcode
/// Using such macro is equivalent to manually defining the following public
/// interface:
/// @code
/// class MyMessage : public
///     comms::Message<
///         ...,
///         comms::option::ExtraTransportFields<MyExtraTransportFields>
///     >
/// {
/// public:
///     enum TransportFieldIdx
///     {
///         TransportFieldIdx_version,
///         TransportFieldIdx_numOfValues
///     };
///
///     auto transportField_version() -> decltype(std::get<TransportFieldIdx_version>(transportFields()))
///     {
///         return std::get<TransportFieldIdx_version>(transportFields());
///     }
///
///     auto transportField_version() const -> decltype(std::get<TransportFieldIdx_version>(transportFields()))
///     {
///         return std::get<TransportFieldIdx_version>(transportFields());
///     }
/// };
/// @endcode
/// Access to the version information given a reference to message object may
/// now be implemented as:
/// @code
/// void handle(MyMessage& msg)
/// {
///     // Retrieve the version numeric value
///     auto versionValue = msg.transportField_version().value();
///
///     ... // do something with version information
/// @endcode
/// @b NOTE, that the defined "extra transport fields" are there to attach 
/// some extra information, delivered as part of transport framing, to message 
/// object itself. These fields are @b NOT getting serialised / deserialised when message
/// object being read / written.
///
/// The @ref comms::Message interface class defines @ref comms::Message::hasTransportFields()
/// static constexpr member function, which may be used at compile time to 
/// determine whether the @ref comms::option::ExtraTransportFields option has been used, i.e. 
/// the message interface class defines mentioned earlier
/// types and functions.
///
/// @subsection page_message_tutorial_interface_summary Interface Options Summary
/// All the options introduced above can be used in any order. They can also
/// be repeated multiple times. However, the option that was defined first takes
/// priority over (or overrides) the same option defined later. @n 
/// For example, the definition below defines @b WriteIterator to be
/// <b>std::uint8_t*</b>, because it was defined with first 
/// comms::option::WriteIterator option:
/// @code
/// typedef comms::Message<
///     ...
///     comms::option::WriteIterator<std::uint8_t*>, 
///     ...
///     comms::option::WriteIterator<std::back_insert_iterator<std::vector<std::uint8_t> >,
///     ...
/// > MyMessage;
/// @endcode  
/// The definition below gives a full interface of all
/// the introduced functions: @b getId(), @b read(), @b write(), @b dispatch(),
/// @b length(), @b valid(), and @b refresh().
/// @code
/// typedef comms::Message<
///     comms::option::BigEndian, // Use big endian for serialisation
///     comms::option::MsgIdType<MyMsgId>, // MyMsgId is an enum type defined earlier
///     comms::option::IdInfoInterface, // Add an ability to retrieve message ID value
///     comms::option::ReadIterator<const std::uint8_t*>, // Use const std::uint8_t* as iterator for reading
///     comms::option::WriteIterator<std::uint8_t*>, // Use std::uint8_t* as iterator for writing
///     comms::option::Handler<MyHandler>, // My MyHandler class declared earlier as a handler for messages
///     comms::option::LengthInfoInterface, // Add an ability to retrieve serialisation length
///     comms::option::ValidCheckInterface, // Add an ability to check contents validity
///     comms::option::RefreshInterface  // Add an ability to refresh message contents
/// > MyMessage;
/// @endcode
///
/// @section page_message_tutorial_implementation Implementation
/// Now it's time to implement custom messages defined in some custom protocol.
/// Let's call them @b Message1, @b Message2, @b Message3, ...
/// Let's assume @b Message1 has two integral values. The first one is
/// unsigned value with possible range of [0 - 1000], serialised using 2 bytes, 
/// and the second one is signed with possible range of [-128 - 127], serialised
/// using only 1 byte. Before defining the actual @b Message1 class, these
/// values need to be defined as @b fields (see @ref page_field_tutorial) and
/// bundled into @b std::tuple.
/// @code
/// typedef comms::Field<comms::option::BigEndian> CommonFieldBase;
///
/// typedef std::tuple <
///     comms::field::IntValue<CommonFieldBase, std::uint16_t, comms::option::ValidNumValueRange<0, 1000> >,
///     comms::field::IntValue<CommonFieldBase, std::int8_t>
/// > Message1Fields;
/// @endcode
/// Then, the custom message @b Message1 class needs to be defined as below:
/// @code
/// // TMessage template parameter is expected to be common interface class.
/// template <typename TMessage>
/// class Message1 : public
///     comms::MessageBase<
///         TMessage, // Interface class for all the messages
///         comms::option::StaticNumIdImpl<MyMsgId_Message1>, 
///         comms::option::MsgType<Message1<TMessage> >, 
///         comms::option::FieldsImpl<Message1Fields> 
///     >
/// {
/// public:
///     // Provide names for the fields
///     COMMS_MSG_FIELDS_ACCESS(value1, value2);
/// };
/// @endcode
/// There are several important elements to pay attention to. All of them
/// are described in the following sub-sections.
/// 
/// @subsection page_message_tutorial_impl_interface Providing Interface Class
/// Every custom message class needs to receive the type of the interface
/// class being used, which is passed as the first template parameter to
/// comms::MessageBase. 
/// @code
/// template <typename TMessage>
/// class Message1 : public
///     comms::MessageBase<
///         TMessage, // Interface class for all the messages
///         ...
///     >
/// {
///     ...
/// };
/// @endcode
/// The comms::MessageBase class in turn will publicly inherit
/// from the provided common interface class. As the result the full class inheritance graph may look
/// like this:
/// @diafile message_class_hierarchy.dia
/// @n
///
/// The comms::MessageBase class will provide implementation to the
/// missing virtual functions or override existing ones, only if they where
/// defined in the interface class, i.e. when appropriate options have been used.
/// If some functionality haven't been requested when defining the interface, 
/// the relevant option, provided
/// to the comms::MessageBase won't have any effect.
///
/// @subsection page_message_tutorial_impl_id Providing Static Numeric ID
/// Most binary communication protocols use numeric values for message identification.
/// In this case the known value needs to be provided to comms::MessageBase
/// using comms::option::StaticNumIdImpl option.
/// @code
/// template <typename TMessage>
/// class Message1 : public
///     comms::MessageBase<
///         TMessage, // Interface class for all the messages
///         comms::option::StaticNumIdImpl<MyMsgId_Message1>, 
///         ...
///     >
/// {
///     ...
/// };
/// @endcode
/// When the ID is provided to the comms::MessageBase class and the provided interface
/// class defines message ID type (see @ref page_message_tutorial_interface_id_type), 
/// the comms::MessageBase class defines the following non-virtual function:
/// @code
/// namespace comms
/// {
/// template <typename TMessage, ...>
/// class MessageBase<Message1<TMessage>, ... > : public TMessage
/// {
/// public:
///     typedef TMessage::MsgIdParamType MsgIdParamType;
///
///     static constexpr MsgIdParamType doGetId()
///     {
///         return MyMsgId_Message1;
///     }
/// };
/// } // namespace comms
/// @endcode
/// If message interface class also allowed polymorphic retrieval of the 
/// ID information (see @ref page_message_tutorial_interface_id_retrieve), the
/// comms::MessageBase class also implements required @b getIdImpl() virtual
/// member functions (see comms::MessageBase::getIdImpl()).
/// @code
/// namespace comms
/// {
/// template <typename TMessage, ...>
/// class MessageBase<Message1<TMessage>, ... > : public TMessage
/// {
/// public:
///     ...
/// protected:
///     virtual MsgIdParamType getIdImpl() const override
///     {
///         return doGetId();
///     }
/// };
/// } // namespace comms
/// @endcode
///
/// @subsection page_message_tutorial_impl_msg_type Providing Actual Message Type
/// In order to automatically provide some of the required functionalities, the
/// comms::MessageBase class needs to be aware of the actual message type that
/// extends it. For this purpose comms::option::MsgType option needs to be
/// used.
/// @code
/// template <typename TMessage>
/// class Message1 : public
///     comms::MessageBase<
///         ...,
///         comms::option::MsgType<Message1<TMessage> >, 
///         ...
///     >
/// {
/// public:
///     ...
/// };
/// @endcode
/// One of the functionalities that require such knowledge is implementation
/// of @b dispatchImpl() virtual function (see @ref page_message_tutorial_interface_handle
/// and comms::MessageBase::dispatchImpl()). The comms::MessageBase class 
/// downcasts its own type to the provided one and invokes appropriate 
/// @b handle() member function from the handling class:
/// @code
/// namespace comms
/// {
/// template <typename TMessage, ...>
/// class MessageBase<Message1<TMessage>, ... > : public TMessage
/// {
/// public:
///     typedef TMessage::Handler Handler;
///     ...
/// protected:
///     virtual void dispatchImpl(Handler& handler) override
///     {
///         handler.handle(static_cast<Message1<TMessage>&>(*this));
///     }
/// };
/// } // namespace comms
/// @endcode
/// @b NOTE, that @b dispatchImpl() function is created if and only if the
/// type of the handler has been provided to the interface class.
///
/// For more details on message dispatching please refer to 
/// @ref page_handler_tutorial page.
///
/// @subsection page_message_tutorial_impl_fields Providing Message Fields
/// As has it been mentioned earlier, the message payload values need to be
/// defined as @b fields (see @ref page_field_tutorial). The knowledge about
/// message fields can be provided to comms::MessageBase class using
/// comms::option::FieldsImpl option.
/// @code
/// typedef comms::Field<comms::option::BigEndian> CommonFieldBase;
///
/// typedef std::tuple <
///     comms::field::IntValue<CommonFieldBase, std::uint16_t, comms::option::ValidNumValueRange<0, 1000> >,
///     comms::field::IntValue<CommonFieldBase, std::int8_t>
/// > Message1Fields;
///
/// template <typename TMessage>
/// class Message1 : public
///     comms::MessageBase<
///         ...
///         comms::option::FieldsImpl<Message1Fields>
///     >
/// {
///     ...
/// };
/// @endcode
/// @b NOTE, that the fields need to be bundled in @b std::tuple.
///
/// When armed with the knowledge of used fields, the comms::MessageBase class
/// implements a bunch of types and @b non-virtual functions to access and operate 
/// the fields, regardless of the polymorphic interface defined in the 
/// interface class:
/// @code
/// namespace comms
/// {
/// template <typename TMessage, ...>
/// class MessageBase<Message1<TMessage>, ... > : public TMessage
/// {
/// public:
///     // Redefining the provided std::tuple of fields as internal type
///     typedef ... AllFields;
///     
///     // Access the stored std::tuple of fields
///     AllFields& fields()
///     {
///         return fields_;
///     }
///
///     // Access the stored std::tuple of fields
///     const AllFields& fields() const
///     {
///         return fields_;
///     }
///
///     // Default implementation of read functionality
///     template <typename TIter>
///     comms::ErrorStatus doRead(TIter& iter, std::size_t len)
///     {
///         // Read all the fields one by one
///     }
///
///     // Default implementation of write functionality
///     template <typename TIter>
///     comms::ErrorStatus doWrite(TIter& iter, std::size_t len) const
///     {
///         // Write all the fields one by one
///     }
///
///     // Default implementation of validity check functionality
///     bool doValid() const
///     {
///         // Validate all the fields one by one
///     }
///
///     // Default implementation of length calculation functionality
///     std::size_t doLength() const
///     {
///         // Summarise the reported lengths of all the fields
///     }
///
///     // Defalut implementation of the refreshing functionality
///     bool doRefresh()
///     {
///         // Invokes refresh() member function of every field and returns
///         // true if at least one of the fields has been updated (returned true).
///     }
///         
///
/// protected:
///     template<std::size_t TIdx, typename TIter > 
///     comms::ErrorStatus doReadFieldsFrom(TIter& iter, std::size_t len)
///     {
///         // Read fields from and including the specified until the end
///     }
///
///     template<std::size_t TIdx, typename TIter > 
///     comms::ErrorStatus doReadFieldsUntil(TIter& iter, std::size_t len)
///     {
///         // Read fields from the beginning until (not including) specified
///     }
///
///     template<std::size_t TFromIdx, std::size_t TToIdx, typename TIter > 
///     comms::ErrorStatus doReadFieldsFromUntil(TIter& iter, std::size_t len)
///     {
///         // Read fields from and including and until (not including) specified.
///     }
///
///     template<std::size_t TIdx, typename TIter > 
///     comms::ErrorStatus doWriteFieldsFrom(TIter& iter, std::size_t len) const
///     {
///         // Write fields from and including the specified until the end
///     }
///
///     template<std::size_t TIdx, typename TIter > 
///     comms::ErrorStatus doWriteFieldsUntil(TIter& iter, std::size_t len) const
///     {
///         // Write fields from the beginning until (not including) specified
///     }
///
///     template<std::size_t TFromIdx, std::size_t TToIdx, typename TIter > 
///     comms::ErrorStatus doWriteFieldsFromUntil(TIter& iter, std::size_t len) const
///     {
///         // Write fields from and including and until (not including) specified.
///     }
///
/// private:
///     AllFields fields_;        
/// };
/// } // namespace comms
/// @endcode
/// However, depending on the options passed to the comms::Message class defining
/// the polymorphic interface, the comms::MessageBase will provide implementation
/// of required virtual functions.
///
/// See also relevant API documentation:
/// @li @ref comms::MessageBase::fields()
/// @li @ref comms::MessageBase::doRead()
/// @li @ref comms::MessageBase::doWrite()
/// @li @ref comms::MessageBase::doLength()
/// @li @ref comms::MessageBase::doValid()
/// @li @ref comms::MessageBase::doRefresh()
/// @li @ref comms::MessageBase::doReadFieldsFrom()
/// @li @ref comms::MessageBase::doReadFieldsUntil()
/// @li @ref comms::MessageBase::doReadFieldsFromUntil()
/// @li @ref comms::MessageBase::doWriteFieldsFrom()
/// @li @ref comms::MessageBase::doWriteFieldsUntil()
/// @li @ref comms::MessageBase::doWriteFieldsFromUntil()
///
/// @subsubsection page_message_tutorial_impl_fields_read Polymorhic Read Implementation
/// If message interface class allowed polymorphic read (see
/// @ref page_message_tutorial_interface_read), the comms::MessageBase will
/// override @b readImpl() function (see comms::MessageBase::readImpl()).
/// @code
/// namespace comms
/// {
/// template <typename TMessage, ...>
/// class MessageBase<Message1<TMessage>, ... > : public TMessage
/// {
/// public:
///     typedef TMessage::ReadIterator ReadIterator;
///
/// protected:
///     virtual comms::ErrorStatus readImpl(ReadIterator& iter, std::size_t len) 
///     {
///         return doRead(iter, len);
///     }    
/// };
/// } // namespace comms
/// @endcode
/// If the actual message type has been provided (see @ref page_message_tutorial_impl_msg_type),
/// the provided @b readImpl() function downcasts its @b this pointer prior
/// to invocation of @b doRead() member function, which allows having custom
/// read functionality (see @ref page_message_tutorial_impl_custom_read below).
/// @code
/// namespace comms
/// {
/// template <typename TMessage, ...>
/// class MessageBase<Message1<TMessage>, ... > : public TMessage
/// {
/// public:
///     typedef TMessage::ReadIterator ReadIterator;
///
/// protected:
///     virtual comms::ErrorStatus readImpl(ReadIterator& iter, std::size_t len) 
///     {
///         return static_cast<Message1<TMessage>*>(this)->doRead(iter, len);
///     }    
/// };
/// } // namespace comms
/// @endcode
/// It is possible to inhibit the generation of @ref comms::MessageBase::readImpl()
/// by passing @ref comms::option::NoReadImpl option to the @ref comms::MessageBase
/// class.
///
/// @subsubsection page_message_tutorial_impl_fields_write Polymorhic Write Implementation
/// If message interface class allowed polymorphic write (see
/// @ref page_message_tutorial_interface_write), the comms::MessageBase will
/// override @b writeImpl() function (see comms::MessageBase::writeImpl()).
/// @code
/// namespace comms
/// {
/// template <typename TMessage, ...>
/// class MessageBase<Message1<TMessage>, ... > : public TMessage
/// {
/// public:
///     typedef TMessage::WriteIterator WriteIterator;
///
/// protected:
///     virtual comms::ErrorStatus writeImpl(WriteIterator& iter, std::size_t len) const 
///     {
///         return doWrite(iter, len);
///     }    
/// };
/// } // namespace comms
/// @endcode
/// If the actual message type has been provided (see @ref page_message_tutorial_impl_msg_type),
/// the provided @b writeImpl() function downcasts its @b this pointer prior
/// to invocation of @b doWrite() member function, which allows having custom
/// write functionality (see @ref page_message_tutorial_impl_custom_write below).
/// @code
/// namespace comms
/// {
/// template <typename TMessage, ...>
/// class MessageBase<Message1<TMessage>, ... > : public TMessage
/// {
/// public:
///     typedef TMessage::WriteIterator WriteIterator;
///
/// protected:
///     virtual comms::ErrorStatus writeImpl(WriteIterator& iter, std::size_t len) const 
///     {
///         return static_cast<const Message1<TMessage>*>(this)->doWrite(iter, len);
///     }    
/// };
/// } // namespace comms
/// @endcode
/// It is possible to inhibit the generation of @ref comms::MessageBase::writeImpl()
/// by passing @ref comms::option::NoWriteImpl option to the @ref comms::MessageBase
/// class.
///
/// @subsubsection page_message_tutorial_impl_fields_length Polymorphic Length Calculation
/// If message interface class allowed polymorphic length calculation (see
/// @ref page_message_tutorial_interface_length), the comms::MessageBase will
/// override @b lengthImpl() function (see comms::MessageBase::lengthImpl()).
/// @code
/// namespace comms
/// {
/// template <typename TMessage, ...>
/// class MessageBase<Message1<TMessage>, ... > : public TMessage
/// {
/// protected:
///     virtual std::size_t lengthImpl() const 
///     {
///         return doLength();
///     }    
/// };
/// } // namespace comms
/// @endcode
/// If the actual message type has been provided (see @ref page_message_tutorial_impl_msg_type),
/// the provided @b lengthImpl() function downcasts its @b this pointer prior
/// to invocation of @b doLength() member function, which allows having custom
/// length calculation functionality (see @ref page_message_tutorial_impl_custom_length below).
/// @code
/// namespace comms
/// {
/// template <typename TMessage, ...>
/// class MessageBase<Message1<TMessage>, ... > : public TMessage
/// {
/// protected:
///     virtual std::size_t lengthImpl() const 
///     {
///         return static_cast<const Message1<TMessage>*>(this)->doLength();
///     }    
/// };
/// } // namespace comms
/// @endcode
/// It is possible to inhibit the generation of @ref comms::MessageBase::lengthImpl()
/// by passing @ref comms::option::NoLengthImpl option to the @ref comms::MessageBase
/// class.
///
/// @subsubsection page_message_tutorial_impl_fields_valid Polymorphic Validity Check
/// If message interface class allowed polymorphic validity check (see
/// @ref page_message_tutorial_interface_valid), the comms::MessageBase will
/// override @b validImpl() function (see comms::MessageBase::validImpl()).
/// @code
/// namespace comms
/// {
/// template <typename TMessage, ...>
/// class MessageBase<Message1<TMessage>, ... > : public TMessage
/// {
/// protected:
///     virtual bool validImpl() const 
///     {
///         return doValid();
///     }    
/// };
/// } // namespace comms
/// @endcode
/// If the actual message type has been provided (see @ref page_message_tutorial_impl_msg_type),
/// the provided @b validImpl() function downcasts its @b this pointer prior
/// to invocation of @b doValid() member function, which allows having custom
/// validity check functionality (see @ref page_message_tutorial_impl_custom_valid below).
/// @code
/// namespace comms
/// {
/// template <typename TMessage, ...>
/// class MessageBase<Message1<TMessage>, ... > : public TMessage
/// {
/// protected:
///     virtual bool validImpl() const 
///     {
///         return static_cast<const Message1<TMessage>*>(this)->doValid();
///     }    
/// };
/// } // namespace comms
/// @endcode
/// It is possible to inhibit the generation of @ref comms::MessageBase::validImpl()
/// by passing @ref comms::option::NoValidImpl option to the @ref comms::MessageBase
/// class.
///
/// @subsubsection page_message_tutorial_impl_fields_refresh Polymorphic Refreh
/// If message interface class allowed polymorphic refresh (see
/// @ref page_message_tutorial_interface_refresh), the comms::MessageBase will
/// override @b refreshImpl() function (see comms::MessageBase::refreshImpl()) 
/// @b only if comms::option::HasDoRefresh option has been passed to comms::MessageBase.
/// Making the generation of the @b refreshImpl() explicit was done to avoid 
/// redundant generation of extra virtual function for messages that are always
/// in consistent state. The comms::Message::readImpl() already provides default
/// implementation of always returning false. 
/// @code
/// namespace comms
/// {
/// template <typename TMessage, ...>
/// class MessageBase<Message1<TMessage>, ... > : public TMessage
/// {
/// protected:
///     virtual bool refreshImpl() 
///     {
///         return doRefresh();
///     }    
/// };
/// } // namespace comms
/// @endcode
/// If the actual message type has been provided (see @ref page_message_tutorial_impl_msg_type),
/// the provided @b refreshImpl() function downcasts its @b this pointer prior
/// to invocation of @b doRefresh() member function, which allows having 
/// @ref page_message_tutorial_impl_custom_refresh.
/// @code
/// namespace comms
/// {
/// template <typename TMessage, ...>
/// class MessageBase<Message1<TMessage>, ... > : public TMessage
/// {
/// protected:
///     virtual bool refreshImpl() 
///     {
///         return static_cast<Message1<TMessage>*>(this)->doRefresh();
///     }    
/// };
/// } // namespace comms
/// @endcode
///
/// @subsection page_message_tutorial_impl_field_names Providing Names to the Fields
/// When preparing message object to send or when handling received message, the
/// fields it contains need to be accessed to set or get their values. The default
/// (build-in) way of achieving that is to get access to the fields tuple 
/// using inherited comms::MessageBase::fields() member function and then using
/// @b std::get() function to access the fields inside the tuple.
/// @code
/// Message1<SomeInterface> msg;
/// auto& allFields = msg.fields();
/// auto& field1 = std::get<0>(allFields);
/// auto& field2 = std::get<1>(allFields);
///
/// field1.value() = 100;
/// field2.value() = 32;
/// sendMessage(msg);
/// @endcode
/// Although it works, it is not very convenient way to access and operate the fields.
/// There is COMMS_MSG_FIELDS_ACCESS() macro that allows to provide meaningful names
/// for the fields:
/// @code
/// template <typename TMessage>
/// class Message1 : public
///     comms::MessageBase<...>
/// {
/// public:
///     // Provide names for the fields
///     COMMS_MSG_FIELDS_ACCESS(value1, value2);
/// };
/// @endcode
/// The said macro creates the following definitions of inner enum @b FieldIdx
/// type as well as @b field_* accessor functions.
/// @code
/// template <typename TMessage>
/// class Message1 : public
///     comms::MessageBase<...>
/// {
/// public:
///     enum FieldIdx
///     {
///         FieldIdx_value1,
///         FieldIdx_value2,
///         FieldIdx_numOfValues
///     }
///
///     auto field_value1() -> decltype(std::get<FieldIdx_value1>(fields()))
///     {
///         return std::get<FieldIdx_value1>(fields());
///     }
///
///     auto field_value1() const -> decltype(std::get<FieldIdx_value1>(fields()))
///     {
///         return std::get<FieldIdx_value1>(fields());
///     }
///
///     auto field_value2() -> decltype(std::get<FieldIdx_value2>(fields()))
///     {
///         return std::get<FieldIdx_value2>(fields());
///     }
///
///     auto field_value2() const -> decltype(std::get<FieldIdx_value2>(fields()))
///     {
///         return std::get<FieldIdx_value2>(fields());
///     }
/// };
/// @endcode
/// As the result, accessing to the fields becomes much easier and clearer:
/// @code
/// Message1<SomeInterface> msg;
/// msg.field_value1().value() = 100;
/// msg.field_value2().value() = 32;
/// sendMessage(msg);
/// @endcode
/// <b style="color:red">WARNING:</b> Some compilers, such as @b clang or earlier
/// versions of @b gcc (v4.9 and earlier) may have problems compiling the 
/// @ref COMMS_MSG_FIELDS_ACCESS() macro
/// even though it contains valid C++11 code to help in identification the 
/// actual base class type. If the compilation failure 
/// happens try to specify the exact base class type using inner @b Base
/// type definition. For example:
/// @code
/// template <typename TMessage>
/// class Message1 : public
///     comms::MessageBase<...>
/// {
///     // Duplicate the base class definition
///     using Base = comms::MessageBase<...>;
/// public:
///     // Provide names for the fields
///     COMMS_MSG_FIELDS_ACCESS(value1, value2);
/// };
/// @endcode
///
/// @subsection page_message_tutorial_impl_custom_read Custom Read Functionality
/// Sometimes the default implementation of read functionality implemented by
/// comms::MessageBase::doRead() may be incomplete or incorrect and may required
/// additional or different implementation. As an example let's define new message
/// type (@b Message2), which has two fields. The first one is a 1 byte bitmask,
/// the least significant bit of which defines whether the second field exists.
/// The second field is optional 2 byte unsigned integer one.
/// @code
/// typedef std::tuple <
///     comms::field::BitmaskValue<
///         CommonFieldBase, 
///         comms::option::FixedLength<1>,
///         comms::option::BitmaskReservedBits<0xfe, 0> 
///     >,
///     comms::field::Optional<comms::field::IntValue<CommonFieldBase, std::uint16_t> >
/// > Message2Fields;
///
/// template <typename TMessage>
/// class Message2 : public
///     comms::MessageBase<
///         TMessage, 
///         comms::option::StaticNumIdImpl<MyMsgId_Message2>, 
///         comms::option::MsgType<Message2<TMessage> >, 
///         comms::option::FieldsImpl<Message2Fields> 
///     >
/// {
/// public:
///     COMMS_MSG_FIELDS_ACCESS(flags, data);
///     
///     template <typename TIter>
///     comms::ErrorStatus doRead(TIter& iter, std::size_t len)
///     {
///         // Get type of the base class
///         using Base = typename std::decay<decltype(comms::toMessageBase(*this))>::type;
///
///         // Read only the flags value
///         auto es = Base::template doReadFieldsUntil<FieldIdx_data>(iter, len);
///         if (es != comms::ErrorStatus::Success) {
///             return es;
///         }
///
///         // Update mode (exists/missing) of the optional value to follow
///         if (field_flags().value() != 0) {
///             field_data().setExists();
///         else {
///             field_data().setMissing();
///         }
///     
///         // Read the rest of the fields
///         return Base::template doReadFieldsFrom<FieldIdx_data>(iter, len - field_flags().length());
///     }
/// };
/// @endcode
/// In order to be able to support custom read functionality, there is a need to
/// @li Use comms::option::MsgType option to specify the actual type of the message,
///     (see @ref page_message_tutorial_impl_msg_type).
/// @li Implement the non-virtual @b doRead() member function with the same
///     signature as provided comms::MessageBase::doRead() with default read
///     functionality implementation.
/// @li Use call to @b comms::toMessageBase(*this) (see @ref comms::toMessageBase()
///     to get a reference to the actual base class (@ref comms::MessageBase).
///
/// When the two conditions above are satisfied, the comms::MessageBase class
/// has inner meta-programming magic to identify the case and invoke the newly
/// provided @b doRead() function from @b readImpl(), when implementing polymorphic
/// read behaviour, instead of default comms::MessageBase::doRead().
///
/// @subsection page_message_tutorial_impl_custom_write Custom Write Functionality
/// On quite rare occasions there may be a need to implement custom write functionality.
/// It can be achieved in the very similar way as @ref page_message_tutorial_impl_custom_read.
/// @li Use comms::option::MsgType option to specify the actual type of the message,
///     (see @ref page_message_tutorial_impl_msg_type).
/// @li Implement the non-virtual @b doWrite() member function with the same
///     signature as provided comms::MessageBase::doWrite() with default write
///     functionality implementation.
///
/// @code
/// template <typename TMessage>
/// class SomeMessage : public comms::MessageBase<...>
/// {
/// public:
///     COMMS_MSG_FIELDS_ACCESS(...);
///     
///     template <typename TIter>
///     comms::ErrorStatus doWrite(TIter& iter, std::size_t len) const
///     {
///         ... 
///     }
/// };
/// @endcode
/// The comms::MessageBase class
/// has inner meta-programming magic to identify the case and invoke the newly
/// provided @b doWrite() function from @b writeImpl() if such is generated.
///
/// @subsection page_message_tutorial_impl_custom_length Custom Length Calculation
/// On quite rare occasions there may be a need to implement custom length calculation functionality.
/// It can be achieved in the very similar way as @ref page_message_tutorial_impl_custom_read.
/// @li Use comms::option::MsgType option to specify the actual type of the message,
///     (see @ref page_message_tutorial_impl_msg_type).
/// @li Implement the non-virtual @b doLength() member function with the same
///     signature as provided comms::MessageBase::doLength().
///
/// @code
/// template <typename TMessage>
/// class SomeMessage : public comms::MessageBase<...>
/// {
/// public:
///     std::size_t doLength() const
///     {
///         ... 
///     }
/// };
/// @endcode
/// The comms::MessageBase class
/// has inner meta-programming magic to identify the case and invoke the newly
/// provided @b doLength() function from @b lengthImpl() if such is generated.
///
/// @subsection page_message_tutorial_impl_custom_valid Custom Validity Check
/// There may be a need to implement custom validity check functionality.
/// It can be achieved in the very similar way as @ref page_message_tutorial_impl_custom_read.
/// @li Use comms::option::MsgType option to specify the actual type of the message,
///     (see @ref page_message_tutorial_impl_msg_type).
/// @li Implement the non-virtual @b doValid() member function with the same
///     signature as provided comms::MessageBase::doValid().
///
/// @code
/// template <typename TMessage>
/// class SomeMessage : public comms::MessageBase<...>
/// {
/// public:
///     bool doValid() const
///     {
///         ... 
///     }
/// };
/// @endcode
/// The comms::MessageBase class
/// has inner meta-programming magic to identify the case and invoke the newly
/// provided @b doValid() function from @b validImpl() if such is generated.
///
/// @subsection page_message_tutorial_impl_custom_refresh Custom Refresh Functionality
/// Let's get back to the definition of @b Message2 mentioned earlier, where
/// the existence of second field (@b data) depends on the value of the least
/// significant bit in the first field (@b flags). During read operation the
/// mode of the @b data is updated after value of the @b flags is read. However,
/// when preparing the same message for write there is a chance that message 
/// contents are going to be put in invalid state:
/// @code
/// Message2<SomeInterface> msg;
/// msg.field_flags().value() = 0x1;
/// msg.field_data().field().value() = 10U;
/// msg.field_data().setMissing(); // Bug, the field should exist
/// sendMessage(msg);
/// @endcode
/// If message is sent, the @b flags will indicate that the @b data field follows,
/// but it won't be serialised, due to being marked as "missing" by mistake. Please note,
/// that all the "write" functions are marked as @b const and are not allowed
/// to update the message fields during write operation. It may be useful to have
/// member function that brings message contents into the valid and consistent
/// state. It should be called @b doRefresh() and return boolean value (@b true
/// in case the message contents were updated, and @b false if they remain
/// intact.
/// @code
/// template <typename TMessage>
/// class Message2 : public comms::MessageBase<...>
/// {
/// public:
///     COMMS_MSG_FIELDS_ACCESS(flags, data);
///     
///     bool doRefresh()
///     {
///         auto expectedDataMode = comms::field::OptionalMode::Missing;
///         if ((field_flags().value() & 0x1) != 0U) {
///             expectedDataMode = comms::field::OptionalMode::Exists;
///         }
///
///         if (field_data().getMode() == expectedDataMode) {
///             // No need to change anything
///             return false;
///         }
///
///         field_data().setMode(expectedDataMode);
///         return true;
///     }
/// };
/// @endcode
/// As the result the code preparing message for sending may look like this:
/// @code
/// Message2<SomeInterface> msg;
/// msg.field_flags().value() = 0x1;
/// msg.field_data().field().value() = 10U;
/// msg.doRefresh(); // Bring message contents into a valid state
/// sendMessage(msg);
/// @endcode
/// If polymorphic refresh functionality is required (see
/// @ref page_message_tutorial_interface_refresh), the actual message class
/// implementation must:
/// @li Implement custom @b doRefresh function as specified above.
/// @li Use comms::option::MsgType option to specify the actual type of the message,
///     (see @ref page_message_tutorial_impl_msg_type).
/// @li Use comms::option::HasDoRefresh option, which will notify comms::MessageBase 
///     about availability of the @b doRefresh function, and allow implementation
///     of @b refreshImpl (see comms::MessageBase::refreshImpl()), if such is
///     required.
///
/// To finalise this section, let's write the final version of @b Message2
/// implementation:
/// @code
/// template <typename TMessage>
/// class Message2 : public
///     comms::MessageBase<
///         TMessage, 
///         comms::option::StaticNumIdImpl<MyMsgId_Message2>, 
///         comms::option::MsgType<Message2<TMessage> >, 
///         comms::option::FieldsImpl<Message2Fields> ,
///         comms::option::HasDoRefresh
///     >
/// {
/// public:
///     COMMS_MSG_FIELDS_ACCESS(flags, data);
///     
///     template <typename TIter>
///     comms::ErrorStatus doRead(TIter& iter, std::size_t len)
///     {
///         ... // see implementation above
///     }
///
///     bool doRefresh()
///     {
///         ... // see implementation above
///     }
/// };
/// @endcode
///
/// @subsection page_message_tutorial_impl_optimisations Extra Optimisations
/// Let's assume that most of the messages are bi-directional, i.e. can be 
/// sent by both ends on the communication link, except @b Message1. The
/// @b Message1 is a "client-only" message, it is sent by the client to
/// the server and never sent by the server back to the client. In this
/// case, when client code is compiled, there is no need for generation of the
/// "read" functionality. And the opposite, when server code is compiled, there
/// is not need to generate code to support "write". If everything left intact,
/// and the interface class definition will require both polymophic "read" and
/// "write", the code both @b readImpl() and @b writeImpl() virtual functions 
/// will be generated occupying unnecessary space in final binary and/or image.
/// For most systems it won't be an issue, but it may be for bare-metal systems 
/// with limited ROM size. The @b COMMS library extra options that can
/// inhibit implementation of the said virtual functions. However there is a
/// need for some extra logic to choose the right option.
/// @code
/// template <bool TClientOnly, bool TServerOnly>
/// struct ExtraMessage1Options
/// {
///     typedef std::tuple<> Type; // No extra options for default variant    
/// }
///
/// // Template specialisation for client-only variant
/// template <>
/// struct ExtraMessage1Options<true, false>
/// {
///     typedef comms::option::NoReadImpl Type;
/// };
///
/// // Template specialisation for server-only variant
/// template <>
/// struct ExtraMessage1Options<false, false>
/// {
///     typedef comms::option::NoWriteImpl Type;
/// };
///
/// template <bool TClientOnly, bool TServerOnly>
/// using ExtraMessage1OptionsT = typename ExtraMessage1Options<TClientOnly, TServerOnly>::Type;
/// @endcode
/// Then the @b Message1 definition can be modified to allow extra options:
/// @code
/// template <typename TMessage, bool TClientOnly = false, bool TServerOnly = false>
/// class Message1 : public
///     comms::MessageBase<
///         TMessage, // Interface class for all the messages
///         comms::option::StaticNumIdImpl<MyMsgId_Message1>, 
///         comms::option::MsgType<Message1<TMessage> >, 
///         comms::option::FieldsImpl<Message1Fields>,
///         ExtraMessage1OptionsT<TClientOnly, TServerOnly>
///     >
/// {
/// public:
///     // Provide names for the fields
///     COMMS_MSG_FIELDS_ACCESS(value1, value2);
/// };
/// @endcode
/// For convenience the alises can also be defined:
/// @code
/// template <typename TMessage>
/// using ClientMessage1 = Message1<TMessage, true, false>;
///
/// template <typename TMessage>
/// using ServerMessage1 = Message1<TMessage, false, true>;
/// @endcode
/// Please note, that both comms::Message and comms::MessageBase receive,
/// variable number of template parameters, which are expected to be option classes
/// from comms::option namespace. The options can be passed as individual ones
/// and/or bundled in @b std::tuple (see definition of internal type of 
/// @b ExtraMessage1Options above). Usage of @b std::tuple can help when there is
/// a need to provide several options in one go.
///
/// There are several more options that can inhibit implementation of virtual @b *Impl()
/// functions by comms::MessageBase. Please refer to the documentation of the latter for
/// the full list.
///
/// @subsection page_message_tutorial_impl_bare_metal Bare Metal Considerations
/// There can be messages that contain strings (see @ref sec_field_tutorial_string)
/// and/or lists (see @ref sec_field_tutorial_array_list). By default, these
/// fields use @b std::string and @b std::vector types respectively for inner
/// value storage. However, these types may be not suitable for bare-metal
/// applications. So, how do we allow usage of different type only when compiling
/// the code for bare-metal environment, while preserving the original behaviour
/// when compiling for any other application? We may use similar technique as in
/// previous section to provide extra option(s) when defining the string type.
///
/// First, there is a need to use comms::option::FixedSizeStorage option to
/// specify the size limit, 0 means no limit and hence no extra option is needed.
/// To specify "no option" either comms::option::EmptyOption option may be used,
/// which will be ignored or empty tuple (@b std::tuple<>).
/// @code
/// template <std::size_t TSizeLimit>
/// struct ExtraStringOptions
/// {
///     typedef comms::option::FixedSizeStorage<TSizeLimit> Type;
/// }
///
/// // Template specialisation for general variant
/// template <>
/// struct ExtraStringOptions<0>
/// {
///     typedef comms::option::EmptyOption Type; // No extra options for default variant    
/// };
///
/// template <std::size_t TSizeLimit>
/// using ExtraStringOptionsT = typename ExtraStringOptions<TSizeLimit>::Type;
/// @endcode
///
/// Second, define the type of the string field, which can receive extra options:
/// For example, string that write 1 byte prefix specifying its length, when 
/// serialised:
/// @code
/// template <std::size_t TSizeLimit>
/// using MyStringField =
///     comms::field::String<
///         CommonFieldBase, 
///         comms::option::SequenceSizeFieldPrefix<
///             comms::field::IntValue<CommonFieldBase, std::uint8_t>
///         >,
///         ExtraStringOptionsT<TSizeLimit> // provide extra options, depending on the provided size limit
/// @endcode
///
/// Third, define the @b std::tuple of message related fields, that allow
/// customisation with the template parameter:
/// @code
/// template <std::size_t TSizeLimit>
/// using Message3Fields = 
///     std::tuple<
///         MyStringField<TSizeLimit>
///     >;
/// @endcode
/// And finally, define the actual message class, that allow the customisation
/// via extra template parameter:
/// @code
/// template <typename TMessage, std::size_t TSizeLimit = 0>
/// class Message3 : public
///     comms::MessageBase<
///         TMessage, 
///         comms::option::StaticNumIdImpl<MyMsgId_Message3>, 
///         comms::option::MsgType<Message3<TMessage, TSizeLimit> >, 
///         comms::option::FieldsImpl<Message3Fields<TSizeLimit> > 
///     >
/// {
/// public:
///     // Provide names for the fields
///     COMMS_MSG_FIELDS_ACCESS(str);
/// };
/// @endcode
/// As the result usual use would be normal definition of :
/// @code
/// typedef Message3<MyMessage> MyMessage3;
/// @endcode
/// While in bare-metal application use extra parameter specifying maximal allowed
/// length, which will result in using comms::util::StaticString class instead of
/// default @b std::string.
/// @code
/// typedef Message3<MyMessage, 128> MyBareMetalMessage2;
/// @endcode
///
/// @subsection page_message_tutorial_impl_summary Implementation Summary
/// The comms::MessageBase class as well as inheriting definitions of the actual message
/// classes may define a significant number of @b non-virtual functions. Thanks to
/// the template nature of the classes and their member functions, these functions
/// get compiled in only if they are used. The virtual functions, on the other hand,
/// will always find their way into the final binary/image, even if they are not used.
/// This is the reason, why custom message classes should never
/// override defined @b *Impl() virtual functions to provide custom polymorphic behaviour.
/// Instead, the comms::MessageBase class should be entrusted with the task by
/// providing it with the right options, indicating what functionality is
/// available. The comms::MessageBase class will implement required @b *Impl()
/// functions <b>if and only if </b> the used interface class requested the
/// polymorphic behaviour. 
///
/// The definition of actual message class that is implemented extending comms::MessageBase
/// while providing appropriate options, becomes applicable to any possible application,
/// whether it's bare-metal with limited resources, server side with full OS support,
/// or extra protocol analysis tools. Every such application may use the same
/// message definition code. All the necessary configuration is performed by
/// defining and choosing the right interface class.
///
/// If there is extended interface in use (see @ref page_message_tutorial_interface), 
/// it is recommended to create extended classes, which inherit from default class
/// definition and implement missing polymorphic functionality:
/// @code
/// template <typename TMessage>
/// class Message1Ext : public Message1<TMessage>
/// {
/// protected:
///     virtual const char* nameImpl() const
///     {
///         static const char* Str = "Message1";
///         return Str;
///     }
/// }
/// @endcode
///

